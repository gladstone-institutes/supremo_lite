

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>supremo_lite.variant_utils &mdash; supremo_lite  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            supremo_lite
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/personalization.html">Personalized Genome Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/variant_centered_sequences.html">Variant-Centered Sequence Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/pam_disruption.html">PAM Disruption Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/prediction_alignment.html">Prediction Alignment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/prediction_alignment_examples.html">Prediction Alignment Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/prediction_alignment_examples.html#variant-type-examples">Variant Type Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/mutagenesis.html">Saturation Mutagenesis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/01_getting_started.html">Getting Started with supremo_lite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/02_personalized_genomes.html">Personalized Genome Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/03_prediction_alignment.html">Prediction Alignment: From Sequences to Aligned Predictions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/04_pam_disruption.html">PAM Disruption Analysis: Identifying CRISPR-Resistant Variants</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conduct.html">Code of Conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">supremo_lite</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">supremo_lite.variant_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for supremo_lite.variant_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Variant reading and handling utilities for supremo_lite.</span>

<span class="sd">This module provides functions for reading variants from VCF files</span>
<span class="sd">and other related operations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>


<div class="viewcode-block" id="BreakendVariant">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.BreakendVariant">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BreakendVariant</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a single breakend variant from a VCF file.</span>

<span class="sd">    This class stores all information needed to process a BND variant,</span>
<span class="sd">    including mate relationships and inserted sequences.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># VCF ID field (e.g., &quot;bnd_W&quot;)</span>
    <span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Chromosome name</span>
    <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># 1-based position</span>
    <span class="n">ref</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Reference allele</span>
    <span class="n">alt</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Complete ALT field (e.g., &quot;G]17:198982]&quot;)</span>
    <span class="n">mate_id</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># MATEID from INFO field</span>
    <span class="n">mate_chrom</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Mate chromosome (parsed from ALT)</span>
    <span class="n">mate_pos</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># Mate position (parsed from ALT)</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Breakend orientation (e.g., &quot;ref_then_mate&quot;)</span>
    <span class="n">inserted_seq</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Novel sequence at junction</span>
    <span class="n">info</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Complete INFO field</span>
    <span class="n">variant_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;SV_BND&quot;</span>  <span class="c1"># Always BND for breakend variants</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate breakend data after initialization.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Breakend ID cannot be empty&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Breakend position must be positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mate_pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Breakend mate position must be positive&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="BreakendPair">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.BreakendPair">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BreakendPair</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a pair of mated breakend variants that create a novel adjacency.</span>

<span class="sd">    This class coordinates the application of both breakends to create</span>
<span class="sd">    complex rearrangements like translocations, inversions, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">breakend1</span><span class="p">:</span> <span class="n">BreakendVariant</span>
    <span class="n">breakend2</span><span class="p">:</span> <span class="n">BreakendVariant</span>
    <span class="n">is_valid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">validation_errors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">validation_warnings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that the two breakends form a consistent pair.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">validation_errors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">validation_warnings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_warnings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Validate mate relationships</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">mate_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Breakend </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> MATEID </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">mate_id</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;does not match mate ID </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">mate_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Breakend </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> MATEID </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">mate_id</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;does not match mate ID </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Validate coordinate consistency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">chrom</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Breakend </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> mate chromosome </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">mate_chrom</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;does not match actual chromosome </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">chrom</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">mate_pos</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Breakend </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> mate position </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">mate_pos</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;does not match actual position </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rearrangement_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the type of rearrangement represented by this breakend pair.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Rearrangement type (&#39;translocation&#39;, &#39;inversion&#39;, &#39;duplication&#39;, &#39;complex&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;invalid&quot;</span>

        <span class="c1"># Check if breakends are on same chromosome</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">chrom</span><span class="p">:</span>
            <span class="c1"># Same chromosome - could be inversion, duplication, or deletion</span>
            <span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">pos</span>
            <span class="n">orient1</span><span class="p">,</span> <span class="n">orient2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">orientation</span>

            <span class="c1"># Simple heuristics for now - detailed implementation would need more logic</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pos1</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>  <span class="c1"># Close positions might be duplication</span>
                <span class="k">return</span> <span class="s2">&quot;duplication&quot;</span>
            <span class="k">elif</span> <span class="n">orient1</span> <span class="o">!=</span> <span class="n">orient2</span><span class="p">:</span>  <span class="c1"># Different orientations suggest inversion</span>
                <span class="k">return</span> <span class="s2">&quot;inversion&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;complex&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Different chromosomes - translocation</span>
            <span class="k">return</span> <span class="s2">&quot;translocation&quot;</span>

<div class="viewcode-block" id="BreakendPair.get_affected_regions">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.BreakendPair.get_affected_regions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_affected_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get genomic regions affected by this breakend pair.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tuples (chrom, start, end) for affected regions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add region around first breakend</span>
        <span class="n">regions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># Include position before breakend</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">ref</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Add region around second breakend</span>
        <span class="n">regions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># Include position before breakend</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">ref</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">regions</span></div>
</div>



<div class="viewcode-block" id="Breakend">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.Breakend">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Breakend</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced breakend with classification information.&quot;&quot;&quot;</span>

    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">ref</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">alt</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">mate_chrom</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">mate_pos</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">inserted_seq</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">classification</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># &#39;paired&#39;, &#39;missing_mate&#39;, &#39;singleton_insertion&#39;</span>
    <span class="n">mate_breakend</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Breakend&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Breakend.from_breakend_variant">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.Breakend.from_breakend_variant">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_breakend_variant</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">variant</span><span class="p">:</span> <span class="n">BreakendVariant</span><span class="p">,</span> <span class="n">classification</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Breakend&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create from BreakendVariant.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">chrom</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ref</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
            <span class="n">alt</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
            <span class="n">mate_chrom</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">,</span>
            <span class="n">mate_pos</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">mate_pos</span><span class="p">,</span>
            <span class="n">orientation</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
            <span class="n">inserted_seq</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">,</span>
            <span class="n">classification</span><span class="o">=</span><span class="n">classification</span><span class="p">,</span>
            <span class="n">mate_breakend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="BNDClassifier">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.BNDClassifier">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BNDClassifier</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BND classifier that doesn&#39;t depend on MATEID fields.</span>

<span class="sd">    Classifies BNDs into categories:</span>

<span class="sd">    1. Paired breakends - have matching mates by coordinates</span>
<span class="sd">    2. Missing mates - reference coordinates not present in VCF (can be inferred)</span>
<span class="sd">    3. Insertions with mates - insertions where mate is present</span>
<span class="sd">    4. Insertions without mates - insertions where mate is missing (inferred)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_breakends</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_index</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Map (chrom, pos) -&gt; breakend</span>

<div class="viewcode-block" id="BNDClassifier.classify_all_breakends">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.BNDClassifier.classify_all_breakends">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_all_breakends</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">vcf_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Breakend</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify all BND variants from a VCF file.</span>

<span class="sd">        Args:</span>
<span class="sd">            vcf_path: Path to VCF file containing BND variants</span>
<span class="sd">            verbose: Print detailed classification information (default: False)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict with keys &#39;paired&#39;, &#39;missing_mate&#39;, &#39;singleton_insertion&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load VCF with variant classification</span>
        <span class="n">variants_df</span> <span class="o">=</span> <span class="n">read_vcf</span><span class="p">(</span><span class="n">vcf_path</span><span class="p">,</span> <span class="n">include_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">classify_variants</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">bnd_variants</span> <span class="o">=</span> <span class="n">variants_df</span><span class="p">[</span>
            <span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INS&quot;</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bnd_variants</span><span class="p">)</span><span class="si">}</span><span class="s2"> BND variants&quot;</span><span class="p">)</span>

        <span class="c1"># Parse all breakends and build coordinate index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_and_index_breakends</span><span class="p">(</span><span class="n">bnd_variants</span><span class="p">)</span>

        <span class="c1"># Classify breakends</span>
        <span class="n">classified</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;paired&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;missing_mate&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;insertion_with_mate&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;insertion_missing_mate&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="n">processed_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">breakend</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_breakends</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">breakend</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Try to find mate by coordinates</span>
            <span class="n">mate_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">,</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_pos</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mate_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_index</span><span class="p">:</span>
                <span class="c1"># Found mate - this is a paired breakend</span>
                <span class="n">mate_breakend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_index</span><span class="p">[</span><span class="n">mate_key</span><span class="p">]</span>

                <span class="c1"># Create enhanced breakends for the pair</span>
                <span class="n">enhanced1</span> <span class="o">=</span> <span class="n">Breakend</span><span class="o">.</span><span class="n">from_breakend_variant</span><span class="p">(</span><span class="n">breakend</span><span class="p">,</span> <span class="s2">&quot;paired&quot;</span><span class="p">)</span>
                <span class="n">enhanced2</span> <span class="o">=</span> <span class="n">Breakend</span><span class="o">.</span><span class="n">from_breakend_variant</span><span class="p">(</span><span class="n">mate_breakend</span><span class="p">,</span> <span class="s2">&quot;paired&quot;</span><span class="p">)</span>

                <span class="n">enhanced1</span><span class="o">.</span><span class="n">mate_breakend</span> <span class="o">=</span> <span class="n">enhanced2</span>
                <span class="n">enhanced2</span><span class="o">.</span><span class="n">mate_breakend</span> <span class="o">=</span> <span class="n">enhanced1</span>

                <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">enhanced1</span><span class="p">,</span> <span class="n">enhanced2</span><span class="p">])</span>
                <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mate_breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No mate found - ALWAYS infer the missing mate and create a fusion</span>
                <span class="c1"># Create an inferred mate breakend</span>
                <span class="n">inferred_mate</span> <span class="o">=</span> <span class="n">BreakendVariant</span><span class="p">(</span>
                    <span class="nb">id</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">_inferred_mate&quot;</span><span class="p">,</span>
                    <span class="n">chrom</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">,</span>
                    <span class="n">pos</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_pos</span><span class="p">,</span>
                    <span class="n">ref</span><span class="o">=</span><span class="s2">&quot;N&quot;</span><span class="p">,</span>  <span class="c1"># Unknown reference at mate position</span>
                    <span class="n">alt</span><span class="o">=</span><span class="s2">&quot;&lt;INFERRED&gt;&quot;</span><span class="p">,</span>
                    <span class="n">mate_id</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="n">mate_chrom</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                    <span class="n">mate_pos</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                    <span class="n">orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_infer_mate_orientation</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">orientation</span><span class="p">),</span>
                    <span class="n">inserted_seq</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>  <span class="c1"># Novel sequence stays on the original breakend</span>
                    <span class="n">info</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;INFERRED_FROM=</span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">variant_type</span><span class="o">=</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Create enhanced breakends for the inferred pair</span>
                <span class="n">enhanced1</span> <span class="o">=</span> <span class="n">Breakend</span><span class="o">.</span><span class="n">from_breakend_variant</span><span class="p">(</span><span class="n">breakend</span><span class="p">,</span> <span class="s2">&quot;paired&quot;</span><span class="p">)</span>
                <span class="n">enhanced2</span> <span class="o">=</span> <span class="n">Breakend</span><span class="o">.</span><span class="n">from_breakend_variant</span><span class="p">(</span><span class="n">inferred_mate</span><span class="p">,</span> <span class="s2">&quot;paired&quot;</span><span class="p">)</span>

                <span class="n">enhanced1</span><span class="o">.</span><span class="n">mate_breakend</span> <span class="o">=</span> <span class="n">enhanced2</span>
                <span class="n">enhanced2</span><span class="o">.</span><span class="n">mate_breakend</span> <span class="o">=</span> <span class="n">enhanced1</span>

                <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">enhanced1</span><span class="p">,</span> <span class="n">enhanced2</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">breakend</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;  INFO: Inferred missing mate for </span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> with novel sequence &#39;</span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">inserted_seq</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;-&gt; created fusion with inferred mate at </span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_pos</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;  INFO: Inferred missing mate for </span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;-&gt; created fusion with inferred mate at </span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_pos</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

                <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="c1"># Apply semantic classification to detect DUP and INV patterns</span>
        <span class="c1"># First detect duplications</span>
        <span class="n">dup_breakends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_duplication_pattern</span><span class="p">(</span><span class="n">classified</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">])</span>

        <span class="c1"># Remove duplication breakends from paired list before inversion detection</span>
        <span class="n">dup_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">dup_breakends</span><span class="p">}</span>
        <span class="n">remaining_paired</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dup_ids</span><span class="p">]</span>

        <span class="c1"># Then detect inversions from remaining breakends</span>
        <span class="n">inv_breakends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_inversion_pattern</span><span class="p">(</span><span class="n">remaining_paired</span><span class="p">)</span>

        <span class="c1"># Remove reclassified breakends from &#39;paired&#39; category and add to semantic categories</span>
        <span class="n">reclassified_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">dup_breakends</span> <span class="o">+</span> <span class="n">inv_breakends</span><span class="p">}</span>
        <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reclassified_ids</span>
        <span class="p">]</span>

        <span class="c1"># Add semantic classifications</span>
        <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;dup_breakends&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dup_breakends</span>
        <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;inv_breakends&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_breakends</span>

        <span class="c1"># Print classification summary</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">BND Classification Summary:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;  Paired breakends (true translocations): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">classified</span><span class="p">[</span><span class="s1">&#39;paired&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Duplication breakends (SV_BND_DUP): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dup_breakends</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Inversion breakends (SV_BND_INV): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inv_breakends</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">total_inferred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">bnd</span>
                    <span class="k">for</span> <span class="n">bnd</span> <span class="ow">in</span> <span class="n">classified</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dup_breakends</span> <span class="o">+</span> <span class="n">inv_breakends</span>
                    <span class="k">if</span> <span class="s2">&quot;inferred&quot;</span> <span class="ow">in</span> <span class="n">bnd</span><span class="o">.</span><span class="n">id</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Inferred mates created: </span><span class="si">{</span><span class="n">total_inferred</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">classified</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_detect_duplication_pattern</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">paired_breakends</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Breakend</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Breakend</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect duplication patterns from paired breakends.</span>

<span class="sd">        A duplication pattern consists of 2 breakends:</span>
<span class="sd">        - BND1: position A pointing to position B</span>
<span class="sd">        - BND2: position B pointing to position A</span>
<span class="sd">        - Same chromosome, A &lt; B (tandem duplication)</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of breakends reclassified as SV_BND_DUP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dup_breakends</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">breakend</span> <span class="ow">in</span> <span class="n">paired_breakends</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">breakend</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">mate</span> <span class="o">=</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span>

            <span class="c1"># Check if this forms a duplication pattern</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="n">mate</span><span class="o">.</span><span class="n">chrom</span>  <span class="c1"># Same chromosome</span>
                <span class="ow">and</span> <span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span>
                <span class="o">==</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_chrom</span>  <span class="c1"># Mate points to same chromosome</span>
                <span class="ow">and</span> <span class="n">mate</span><span class="o">.</span><span class="n">chrom</span>
                <span class="o">==</span> <span class="n">mate</span><span class="o">.</span><span class="n">mate_chrom</span>  <span class="c1"># Mate&#39;s mate points to same chromosome</span>
                <span class="ow">and</span> <span class="n">breakend</span><span class="o">.</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">mate</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">):</span>  <span class="c1"># Different positions</span>

                <span class="c1"># Check mutual pointing (A-&gt;B, B-&gt;A)</span>
                <span class="n">points_to_mate</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">breakend</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">mate</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">and</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_pos</span> <span class="o">==</span> <span class="n">mate</span><span class="o">.</span><span class="n">pos</span>
                <span class="p">)</span>
                <span class="n">mate_points_back</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">mate</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">and</span> <span class="n">mate</span><span class="o">.</span><span class="n">mate_pos</span> <span class="o">==</span> <span class="n">breakend</span><span class="o">.</span><span class="n">pos</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">points_to_mate</span> <span class="ow">and</span> <span class="n">mate_points_back</span><span class="p">:</span>
                    <span class="c1"># Check orientations to determine if this is truly a duplication or inversion</span>
                    <span class="c1"># Duplication: orientations should be compatible with copy-paste behavior</span>
                    <span class="c1"># Inversion: orientations should indicate sequence reversal</span>

                    <span class="n">orientation1</span> <span class="o">=</span> <span class="n">breakend</span><span class="o">.</span><span class="n">orientation</span>
                    <span class="n">orientation2</span> <span class="o">=</span> <span class="n">mate</span><span class="o">.</span><span class="n">orientation</span>

                    <span class="c1"># Simple heuristic: if we have more than 2 breakends on same chromosome pointing to each other,</span>
                    <span class="c1"># it&#39;s likely an inversion pattern, not duplication (which typically involves 2 breakends)</span>
                    <span class="c1"># Count breakends on this chromosome</span>
                    <span class="n">same_chrom_breakends</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">b</span>
                        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">paired_breakends</span>
                        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span>
                    <span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">same_chrom_breakends</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Likely inversion pattern with multiple breakends - skip duplication classification</span>
                        <span class="k">continue</span>

                    <span class="c1"># This is a duplication pattern - reclassify both breakends</span>
                    <span class="n">dup_breakend1</span> <span class="o">=</span> <span class="n">Breakend</span><span class="o">.</span><span class="n">from_breakend_variant</span><span class="p">(</span>
                        <span class="n">BreakendVariant</span><span class="p">(</span>
                            <span class="nb">id</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                            <span class="n">chrom</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                            <span class="n">pos</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                            <span class="n">ref</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                            <span class="n">alt</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                            <span class="n">mate_id</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">breakend</span><span class="p">,</span> <span class="s2">&quot;mate_id&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                            <span class="n">mate_chrom</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">,</span>
                            <span class="n">mate_pos</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_pos</span><span class="p">,</span>
                            <span class="n">orientation</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
                            <span class="n">inserted_seq</span><span class="o">=</span><span class="n">breakend</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">,</span>
                            <span class="n">info</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                            <span class="n">variant_type</span><span class="o">=</span><span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">dup_breakend2</span> <span class="o">=</span> <span class="n">Breakend</span><span class="o">.</span><span class="n">from_breakend_variant</span><span class="p">(</span>
                        <span class="n">BreakendVariant</span><span class="p">(</span>
                            <span class="nb">id</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                            <span class="n">chrom</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                            <span class="n">pos</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                            <span class="n">ref</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                            <span class="n">alt</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                            <span class="n">mate_id</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">mate</span><span class="p">,</span> <span class="s2">&quot;mate_id&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                            <span class="n">mate_chrom</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">,</span>
                            <span class="n">mate_pos</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">mate_pos</span><span class="p">,</span>
                            <span class="n">orientation</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
                            <span class="n">inserted_seq</span><span class="o">=</span><span class="n">mate</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">,</span>
                            <span class="n">info</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                            <span class="n">variant_type</span><span class="o">=</span><span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># Maintain mate relationships</span>
                    <span class="n">dup_breakend1</span><span class="o">.</span><span class="n">mate_breakend</span> <span class="o">=</span> <span class="n">dup_breakend2</span>
                    <span class="n">dup_breakend2</span><span class="o">.</span><span class="n">mate_breakend</span> <span class="o">=</span> <span class="n">dup_breakend1</span>

                    <span class="n">dup_breakends</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">dup_breakend1</span><span class="p">,</span> <span class="n">dup_breakend2</span><span class="p">])</span>
                    <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mate</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dup_breakends</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_detect_inversion_pattern</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">paired_breakends</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Breakend</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Breakend</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect inversion patterns from paired breakends.</span>

<span class="sd">        An inversion pattern consists of 4 breakends forming 2 pairs:</span>
<span class="sd">        - Pair 1: Outer breakpoints (A, B) with inverted orientations</span>
<span class="sd">        - Pair 2: Inner breakpoints (C, D) with inverted orientations</span>
<span class="sd">        - Same chromosome, positions in order A &lt; C &lt; D &lt; B</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of breakends reclassified as SV_BND_INV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inv_breakends</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Group breakends by chromosome for efficiency</span>
        <span class="n">chrom_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">breakend</span> <span class="ow">in</span> <span class="n">paired_breakends</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">breakend</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">breakend</span><span class="o">.</span><span class="n">chrom</span>
            <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chrom_groups</span><span class="p">:</span>
                <span class="n">chrom_groups</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">chrom_groups</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">breakend</span><span class="p">)</span>

        <span class="c1"># Look for inversion patterns within each chromosome</span>
        <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">breakends</span> <span class="ow">in</span> <span class="n">chrom_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">breakends</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># Need at least 4 breakends for inversion</span>
                <span class="k">continue</span>

            <span class="c1"># Sort by position</span>
            <span class="n">breakends_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">breakends</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

            <span class="c1"># Check for inversion patterns - simplified heuristic</span>
            <span class="c1"># Look for breakends that point inward (toward each other)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">breakends_sorted</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">breakend1</span> <span class="o">=</span> <span class="n">breakends_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">breakend2</span> <span class="o">=</span> <span class="n">breakends_sorted</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">breakend1</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span>
                    <span class="ow">or</span> <span class="n">breakend2</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">breakend1</span><span class="o">.</span><span class="n">mate_breakend</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">breakend2</span><span class="o">.</span><span class="n">mate_breakend</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Check if this is part of an inversion pattern</span>
                <span class="c1"># For inversion: we expect 4 breakends on same chromosome with crossed connections</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">breakend1</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="n">breakend2</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="n">chrom</span>
                    <span class="ow">and</span> <span class="n">breakend1</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">breakend2</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">chrom</span>
                    <span class="ow">and</span> <span class="n">breakend1</span><span class="o">.</span><span class="n">mate_breakend</span>
                    <span class="ow">and</span> <span class="n">breakend2</span><span class="o">.</span><span class="n">mate_breakend</span>
                <span class="p">):</span>

                    <span class="c1"># Check if the 4 breakends form inversion pattern</span>
                    <span class="c1"># Simple heuristic: 4 breakends all pointing to each other on same chromosome</span>
                    <span class="n">same_chrom_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">b</span>
                            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">breakends_sorted</span>
                            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="n">chrom</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">chrom</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">same_chrom_count</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="c1"># Reclassify all 4 breakends as inversion</span>
                        <span class="k">for</span> <span class="n">breakend_to_classify</span> <span class="ow">in</span> <span class="n">breakends_sorted</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="c1"># Reclassify as inversion</span>
                            <span class="n">inv_breakend</span> <span class="o">=</span> <span class="n">Breakend</span><span class="o">.</span><span class="n">from_breakend_variant</span><span class="p">(</span>
                                <span class="n">BreakendVariant</span><span class="p">(</span>
                                    <span class="nb">id</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                    <span class="n">chrom</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                                    <span class="n">pos</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                                    <span class="n">ref</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                                    <span class="n">alt</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                                    <span class="n">mate_id</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span>
                                        <span class="n">breakend_to_classify</span><span class="p">,</span> <span class="s2">&quot;mate_id&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                                    <span class="p">),</span>
                                    <span class="n">mate_chrom</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">,</span>
                                    <span class="n">mate_pos</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">mate_pos</span><span class="p">,</span>
                                    <span class="n">orientation</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
                                    <span class="n">inserted_seq</span><span class="o">=</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">,</span>
                                    <span class="n">info</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                    <span class="n">variant_type</span><span class="o">=</span><span class="s2">&quot;SV_BND_INV&quot;</span><span class="p">,</span>
                                <span class="p">),</span>
                                <span class="s2">&quot;SV_BND_INV&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">inv_breakends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv_breakend</span><span class="p">)</span>
                            <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend_to_classify</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

                        <span class="c1"># Exit the loop since we processed all breakends for this chromosome</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">inv_breakends</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_infer_mate_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_orientation</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer the orientation of a missing mate breakend based on the original breakend&#39;s orientation.</span>

<span class="sd">        BND orientation pairs (original -&gt; inferred mate):</span>

<span class="sd">        - t[p[ -&gt; ]p]t</span>
<span class="sd">        - t]p] -&gt; [p[t</span>
<span class="sd">        - ]p]t -&gt; t[p[</span>
<span class="sd">        - [p[t -&gt; t]p]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orientation_pairs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;t[p[&quot;</span><span class="p">:</span> <span class="s2">&quot;]p]t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;t]p]&quot;</span><span class="p">:</span> <span class="s2">&quot;[p[t&quot;</span><span class="p">,</span>
            <span class="s2">&quot;]p]t&quot;</span><span class="p">:</span> <span class="s2">&quot;t[p[&quot;</span><span class="p">,</span>
            <span class="s2">&quot;[p[t&quot;</span><span class="p">:</span> <span class="s2">&quot;t]p]&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">orientation_pairs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">original_orientation</span><span class="p">,</span> <span class="s2">&quot;]p]t&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_and_index_breakends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnd_variants</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse breakends and build coordinate index.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">bnd_variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Parse ALT field</span>
                <span class="n">alt_info</span> <span class="o">=</span> <span class="n">parse_breakend_alt</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Could not parse ALT field for </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Parse INFO field for optional MATEID</span>
                <span class="n">info_dict</span> <span class="o">=</span> <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                <span class="n">mate_id</span> <span class="o">=</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;MATEID&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># Create BreakendVariant</span>
                <span class="n">breakend_var</span> <span class="o">=</span> <span class="n">BreakendVariant</span><span class="p">(</span>
                    <span class="nb">id</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
                    <span class="n">chrom</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">],</span>
                    <span class="n">pos</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">],</span>
                    <span class="n">ref</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">],</span>
                    <span class="n">alt</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">],</span>
                    <span class="n">mate_id</span><span class="o">=</span><span class="n">mate_id</span><span class="p">,</span>
                    <span class="n">mate_chrom</span><span class="o">=</span><span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">],</span>
                    <span class="n">mate_pos</span><span class="o">=</span><span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">],</span>
                    <span class="n">orientation</span><span class="o">=</span><span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">],</span>
                    <span class="n">inserted_seq</span><span class="o">=</span><span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;inserted_seq&quot;</span><span class="p">],</span>
                    <span class="n">info</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                    <span class="n">variant_type</span><span class="o">=</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">all_breakends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">breakend_var</span><span class="p">)</span>

                <span class="c1"># Index by coordinates</span>
                <span class="n">coord_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">breakend_var</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">breakend_var</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_index</span><span class="p">[</span><span class="n">coord_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">breakend_var</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing breakend </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_count_vcf_header_lines</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the number of header lines in a VCF file.</span>

<span class="sd">    VCF files have two types of header lines:</span>
<span class="sd">    - Lines starting with ## (metadata)</span>
<span class="sd">    - Line starting with #CHROM (column header)</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to VCF file</span>

<span class="sd">    Returns:</span>
<span class="sd">        Number of lines to skip (all ## lines + the #CHROM line)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">header_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">):</span>
                <span class="n">header_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                <span class="n">header_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Skip the #CHROM header line</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c1"># Reached data lines</span>
    <span class="k">return</span> <span class="n">header_count</span>


<div class="viewcode-block" id="read_vcf">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.read_vcf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_vcf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">include_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">classify_variants</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read VCF file into pandas DataFrame with enhanced variant classification.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to VCF file</span>
<span class="sd">        include_info: Whether to include INFO field (default: True)</span>
<span class="sd">        classify_variants: Whether to classify variant types (default: True)</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with columns: chrom, pos1, id, ref, alt, [info], [variant_type]</span>

<span class="sd">    Notes:</span>
<span class="sd">        - INFO field parsing enables structural variant classification</span>
<span class="sd">        - variant_type column uses VCF 4.2 compliant classification</span>
<span class="sd">        - Compatible with existing code expecting basic 5-column format</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine columns to read based on parameters</span>
    <span class="k">if</span> <span class="n">include_info</span><span class="p">:</span>
        <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>  <span class="c1"># Include INFO field</span>
        <span class="n">base_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;pos1&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;alt&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># Include ID field by default</span>
        <span class="n">base_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;pos1&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;alt&quot;</span><span class="p">]</span>

    <span class="c1"># Count header lines for VCF line tracking (needed for vcf_line column)</span>
    <span class="n">header_count</span> <span class="o">=</span> <span class="n">_count_vcf_header_lines</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="c1"># Read VCF using pandas with comment=&#39;#&#39; to skip all header lines automatically</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">base_columns</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="n">usecols</span>
    <span class="p">)</span>

    <span class="c1"># Add VCF line numbers for debugging (1-indexed, accounting for header lines)</span>
    <span class="c1"># Line number = header_lines + 1 (for 1-indexing) + row_index</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;vcf_line&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">header_count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Validate that pos1 column is numeric</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Position column (second column) must be numeric, got </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;pos1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Filter out multiallelic variants (ALT alleles containing commas)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">_filter_multiallelic_variants</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># Add variant classification if requested</span>
    <span class="k">if</span> <span class="n">classify_variants</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">classify_variant_type</span><span class="p">(</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">],</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">],</span>
                <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span> <span class="k">if</span> <span class="n">include_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="c1"># Note: INV and DUP variants represented by multiple BNDs are handled by</span>
    <span class="c1"># BNDClassifier and group_variants_by_semantic_type() functions</span>
    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="read_vcf_chunked">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.read_vcf_chunked">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_vcf_chunked</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">n_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">classify_variants</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read VCF file in chunks using generator with enhanced variant classification.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to VCF file</span>
<span class="sd">        n_chunks: Number of chunks to split variants into (default: 1)</span>
<span class="sd">        include_info: Whether to include INFO field (default: True)</span>
<span class="sd">        classify_variants: Whether to classify variant types (default: True)</span>

<span class="sd">    Yields:</span>
<span class="sd">        DataFrame chunks with columns: chrom, pos1, id, ref, alt, [info], [variant_type]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine columns to read based on parameters</span>
    <span class="k">if</span> <span class="n">include_info</span><span class="p">:</span>
        <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>  <span class="c1"># Include INFO field</span>
        <span class="n">base_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;pos1&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;alt&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># Include ID field by default</span>
        <span class="n">base_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;pos1&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;alt&quot;</span><span class="p">]</span>

    <span class="c1"># Count header lines for VCF line tracking (needed for vcf_line column)</span>
    <span class="n">header_count</span> <span class="o">=</span> <span class="n">_count_vcf_header_lines</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="c1"># Read VCF using pandas with comment=&#39;#&#39; to skip all header lines automatically</span>
    <span class="n">full_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">base_columns</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="n">usecols</span>
    <span class="p">)</span>

    <span class="c1"># Handle empty DataFrame</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Add VCF line numbers for debugging (1-indexed, accounting for header lines)</span>
    <span class="c1"># Line number = header_lines + 1 (for 1-indexing) + row_index</span>
    <span class="n">full_df</span><span class="p">[</span><span class="s2">&quot;vcf_line&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_df</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">header_count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Validate that pos1 column is numeric</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">full_df</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Position column (second column) must be numeric, got </span><span class="si">{</span><span class="n">full_df</span><span class="p">[</span><span class="s1">&#39;pos1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Filter out multiallelic variants (ALT alleles containing commas)</span>
    <span class="n">full_df</span> <span class="o">=</span> <span class="n">_filter_multiallelic_variants</span><span class="p">(</span><span class="n">full_df</span><span class="p">)</span>

    <span class="c1"># Add variant classification if requested</span>
    <span class="k">if</span> <span class="n">classify_variants</span><span class="p">:</span>
        <span class="n">full_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">classify_variant_type</span><span class="p">(</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">],</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">],</span>
                <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span> <span class="k">if</span> <span class="n">include_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Split into chunks using numpy array_split</span>
    <span class="c1"># Use numpy array_split to create n_chunks approximately equal chunks</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">full_df</span><span class="p">)),</span> <span class="n">n_chunks</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">chunk_indices</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">full_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">chunk_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_vcf_chromosomes">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.get_vcf_chromosomes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_vcf_chromosomes</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get list of chromosomes in VCF file without loading all variants.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to VCF file</span>

<span class="sd">    Returns:</span>
<span class="sd">        Set of chromosome names found in the VCF file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chromosomes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#CHROM&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># Parse first column (chromosome)</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chromosomes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chromosomes</span></div>



<div class="viewcode-block" id="read_vcf_chromosome">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.read_vcf_chromosome">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_vcf_chromosome</span><span class="p">(</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">target_chromosome</span><span class="p">,</span> <span class="n">include_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">classify_variants</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read VCF file for a specific chromosome only with enhanced variant classification.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to VCF file</span>
<span class="sd">        target_chromosome: Chromosome name to filter for</span>
<span class="sd">        include_info: Whether to include INFO field (default: True)</span>
<span class="sd">        classify_variants: Whether to classify variant types (default: True)</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with variants only from specified chromosome</span>
<span class="sd">        (columns: chrom, pos1, id, ref, alt, [info], [variant_type])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chromosome_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">header_line</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#CHROM&quot;</span><span class="p">):</span>
                <span class="n">header_line</span> <span class="o">=</span> <span class="n">line</span>
                <span class="k">continue</span>

            <span class="c1"># Check if this line is for our target chromosome</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">chrom</span> <span class="o">==</span> <span class="n">target_chromosome</span><span class="p">:</span>
                <span class="n">chromosome_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="c1"># Determine columns to read based on parameters</span>
    <span class="k">if</span> <span class="n">include_info</span><span class="p">:</span>
        <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>  <span class="c1"># Include INFO field</span>
        <span class="n">base_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;pos1&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;alt&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># Include ID field by default</span>
        <span class="n">base_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;pos1&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;alt&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">chromosome_lines</span><span class="p">:</span>
        <span class="c1"># Return empty DataFrame with correct columns if no variants found</span>
        <span class="n">empty_columns</span> <span class="o">=</span> <span class="n">base_columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">classify_variants</span><span class="p">:</span>
            <span class="n">empty_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;variant_type&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">empty_columns</span><span class="p">)</span>

    <span class="c1"># Combine header and chromosome-specific lines</span>
    <span class="n">vcf_data</span> <span class="o">=</span> <span class="n">header_line</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chromosome_lines</span><span class="p">)</span>

    <span class="c1"># Parse into DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">vcf_data</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="n">usecols</span><span class="p">)</span>

    <span class="c1"># Set column names</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">base_columns</span>

    <span class="c1"># Validate that pos1 column is numeric</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Position column (second column) must be numeric, got </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;pos1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Filter out multiallelic variants (ALT alleles containing commas)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_filter_multiallelic_variants</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># Add variant classification if requested</span>
    <span class="k">if</span> <span class="n">classify_variants</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">classify_variant_type</span><span class="p">(</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">],</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">],</span>
                <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span> <span class="k">if</span> <span class="n">include_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="read_vcf_chromosomes_chunked">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.read_vcf_chromosomes_chunked">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_vcf_chromosomes_chunked</span><span class="p">(</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">target_chromosomes</span><span class="p">,</span> <span class="n">n_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">classify_variants</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read VCF file for specific chromosomes in chunks with enhanced variant classification.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to VCF file</span>
<span class="sd">        target_chromosomes: List/set of chromosome names to include</span>
<span class="sd">        n_chunks: Number of chunks per chromosome (default: 1)</span>
<span class="sd">        include_info: Whether to include INFO field (default: True)</span>
<span class="sd">        classify_variants: Whether to classify variant types (default: True)</span>

<span class="sd">    Yields:</span>
<span class="sd">        Tuples of (chromosome, variants_dataframe) for each chunk</span>
<span class="sd">        DataFrame columns: chrom, pos1, id, ref, alt, [info], [variant_type]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_chromosomes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">target_chromosomes</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">target_chromosomes</span><span class="p">:</span>
        <span class="n">chrom_variants</span> <span class="o">=</span> <span class="n">read_vcf_chromosome</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">include_info</span><span class="p">,</span> <span class="n">classify_variants</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom_variants</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">n_chunks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Single chunk - yield all variants for this chromosome</span>
            <span class="k">yield</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">chrom_variants</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Multiple chunks - split chromosome variants into n_chunks</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom_variants</span><span class="p">)),</span> <span class="n">n_chunks</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">chunk_df</span> <span class="o">=</span> <span class="n">chrom_variants</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">chunk_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">_chunk_</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chunk_df</span></div>



<div class="viewcode-block" id="group_variants_by_semantic_type">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.group_variants_by_semantic_type">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_variants_by_semantic_type</span><span class="p">(</span>
    <span class="n">variants_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">vcf_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group variants by semantic type for unified processing.</span>

<span class="sd">    This function groups variants so that DUP and SV_BND_DUP are processed together,</span>
<span class="sd">    INV and SV_BND_INV are processed together, etc.</span>

<span class="sd">    Args:</span>
<span class="sd">        variants_df: DataFrame with variants including variant_type column</span>
<span class="sd">        vcf_path: Optional VCF path for BND semantic classification</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict with keys: &#39;standard&#39;, &#39;dup_variants&#39;, &#39;inv_variants&#39;, &#39;bnd_variants&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grouped</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;standard&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span>
        <span class="s2">&quot;dup_variants&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span>
        <span class="s2">&quot;inv_variants&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span>
        <span class="s2">&quot;bnd_variants&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span>
    <span class="p">}</span>

    <span class="c1"># Standard variants (SNV, INS, DEL, MNV)</span>
    <span class="n">standard_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SNV&quot;</span><span class="p">,</span> <span class="s2">&quot;MNV&quot;</span><span class="p">,</span> <span class="s2">&quot;INS&quot;</span><span class="p">,</span> <span class="s2">&quot;DEL&quot;</span><span class="p">,</span> <span class="s2">&quot;complex&quot;</span><span class="p">]</span>
    <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;standard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">variants_df</span><span class="p">[</span>
        <span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">standard_types</span><span class="p">)</span>
    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Symbolic DUP variants</span>
    <span class="n">dup_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SV_DUP&quot;</span><span class="p">]</span>
    <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">variants_df</span><span class="p">[</span>
        <span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dup_types</span><span class="p">)</span>
    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Symbolic INV variants</span>
    <span class="n">inv_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SV_INV&quot;</span><span class="p">]</span>
    <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">variants_df</span><span class="p">[</span>
        <span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">inv_types</span><span class="p">)</span>
    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Handle BND variants with semantic classification</span>
    <span class="n">bnd_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INS&quot;</span><span class="p">]</span>
    <span class="n">bnd_variants</span> <span class="o">=</span> <span class="n">variants_df</span><span class="p">[</span><span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bnd_types</span><span class="p">)]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vcf_path</span><span class="p">:</span>
        <span class="c1"># Use BNDClassifier to get semantic classifications</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">BNDClassifier</span><span class="p">()</span>
        <span class="n">classified_breakends</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">classify_all_breakends</span><span class="p">(</span>
            <span class="n">vcf_path</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># Extract variant IDs for each semantic type</span>
        <span class="n">dup_bnd_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">classified_breakends</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dup_breakends&quot;</span><span class="p">,</span> <span class="p">[])}</span>
        <span class="n">inv_bnd_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">classified_breakends</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;inv_breakends&quot;</span><span class="p">,</span> <span class="p">[])}</span>
        <span class="n">true_bnd_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">classified_breakends</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;paired&quot;</span><span class="p">,</span> <span class="p">[])}</span>

        <span class="c1"># Group BND variants by semantic type</span>
        <span class="n">dup_bnd_variants</span> <span class="o">=</span> <span class="n">bnd_variants</span><span class="p">[</span><span class="n">bnd_variants</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dup_bnd_ids</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">inv_bnd_variants</span> <span class="o">=</span> <span class="n">bnd_variants</span><span class="p">[</span><span class="n">bnd_variants</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">inv_bnd_ids</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">true_bnd_variants</span> <span class="o">=</span> <span class="n">bnd_variants</span><span class="p">[</span><span class="n">bnd_variants</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">true_bnd_ids</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Update variant_type for semantic consistency</span>
        <span class="n">dup_bnd_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SV_BND_DUP&quot;</span>
        <span class="n">inv_bnd_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SV_BND_INV&quot;</span>

        <span class="c1"># Combine with symbolic variants</span>
        <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">],</span> <span class="n">dup_bnd_variants</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">],</span> <span class="n">inv_bnd_variants</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;bnd_variants&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_bnd_variants</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No BND semantic classification possible</span>
        <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;bnd_variants&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bnd_variants</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">grouped</span></div>



<div class="viewcode-block" id="parse_vcf_info">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.parse_vcf_info">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_vcf_info</span><span class="p">(</span><span class="n">info_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse VCF INFO field to extract variant information according to VCF 4.2 specification.</span>

<span class="sd">    Args:</span>
<span class="sd">        info_string: VCF INFO field string (e.g., &quot;SVTYPE=INV;END=1234;SVLEN=100&quot;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Parsed INFO field values with appropriate type conversion</span>

<span class="sd">    VCF 4.2 INFO field specification:</span>

<span class="sd">        - Key=Value pairs separated by semicolons</span>
<span class="sd">        - Boolean flags have no value (key presence = True)</span>
<span class="sd">        - Numeric values auto-converted to int/float</span>
<span class="sd">        - Reserved keys: AA, AC, AF, AN, BQ, CIGAR, DB, DP, END, H2, H3, MQ, MQ0, NS, SB, etc.</span>

<span class="sd">    Examples:</span>

<span class="sd">        &gt;&gt;&gt; parse_vcf_info(&quot;SVTYPE=INV;END=1234;SVLEN=100&quot;)</span>
<span class="sd">        {&#39;SVTYPE&#39;: &#39;INV&#39;, &#39;END&#39;: 1234, &#39;SVLEN&#39;: 100}</span>

<span class="sd">        &gt;&gt;&gt; parse_vcf_info(&quot;DB;H2;AF=0.5&quot;)</span>
<span class="sd">        {&#39;DB&#39;: True, &#39;H2&#39;: True, &#39;AF&#39;: 0.5}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info_string</span> <span class="ow">or</span> <span class="n">info_string</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">info_dict</span>

    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">info_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="s2">&quot;=&quot;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

            <span class="c1"># Handle comma-separated lists (like AC=1,2,3)</span>
            <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">value_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
                <span class="c1"># Try to convert list elements to numbers</span>
                <span class="n">converted_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value_list</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                            <span class="n">converted_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">converted_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">converted_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">info_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">converted_list</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Single value - try numeric conversion</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                        <span class="n">info_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">info_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">info_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Boolean flag (presence = True)</span>
            <span class="n">info_dict</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">info_dict</span></div>



<div class="viewcode-block" id="classify_variant_type">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.classify_variant_type">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">classify_variant_type</span><span class="p">(</span>
    <span class="n">ref_allele</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">alt_allele</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">info_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classify variant type according to VCF 4.2 specification using comprehensive heuristics.</span>

<span class="sd">    Note: This function only correctly classifies variants that are represented in a single</span>
<span class="sd">    VCF record, this means that an additional classification step is needed for BNDs that</span>
<span class="sd">    actually represent INV or DUP variants as those can be represented as 4 or 2 VCF records</span>
<span class="sd">    respectively.</span>

<span class="sd">    This function implements the complete VCF 4.2 variant classification rules with proper</span>
<span class="sd">    handling of structural variants, standard sequence variants, and edge cases.</span>

<span class="sd">    Args:</span>
<span class="sd">        ref_allele: Reference allele sequence (REF field)</span>
<span class="sd">        alt_allele: Alternate allele sequence (ALT field)</span>
<span class="sd">        info_dict: Parsed INFO field dictionary (optional, for structural variants)</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: Variant type classification</span>

<span class="sd">    VCF 4.2 Variant Types (in classification priority order):</span>

<span class="sd">        - &#39;complex&#39;: Complex/multiallelic variants (ALT contains comma)</span>
<span class="sd">        - &#39;missing&#39;: Missing/upstream deletion allele (ALT = &#39;*&#39;)</span>
<span class="sd">        - &#39;SV_INV&#39;: Inversion structural variant</span>
<span class="sd">        - &#39;SV_DUP&#39;: Duplication structural variant</span>
<span class="sd">        - &#39;SV_DEL&#39;: Deletion structural variant</span>
<span class="sd">        - &#39;SV_INS&#39;: Insertion structural variant</span>
<span class="sd">        - &#39;SV_CNV&#39;: Copy number variant</span>
<span class="sd">        - &#39;SV_BND&#39;: Breakend/translocation</span>
<span class="sd">        - &#39;SV_BND_INS&#39;: Breakend/translocation with inserted sequence</span>
<span class="sd">        - &#39;SNV&#39;: Single nucleotide variant</span>
<span class="sd">        - &#39;MNV&#39;: Milti-nucleotide variant (alt len = ref len but no prefix)</span>
<span class="sd">        - &#39;INS&#39;: Sequence insertion</span>
<span class="sd">        - &#39;DEL&#39;: Sequence deletion</span>
<span class="sd">        - &#39;complex&#39;: Complex/multi-nucleotide variant (same length substitution)</span>
<span class="sd">        - &#39;unknown&#39;: Unclassifiable variant</span>

<span class="sd">    Note: MNV is not part of the official VCF 4.2 spec, they are treated the same as SNVs</span>
<span class="sd">    for all functions in supremo_lite.</span>

<span class="sd">    Examples:</span>

<span class="sd">        # Multiallelic variants</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;A&#39;, &#39;G,T&#39;)</span>
<span class="sd">        &#39;multiallelic&#39;</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;T&#39;, &#39;TGGG,C&#39;)</span>
<span class="sd">        &#39;multiallelic&#39;</span>

<span class="sd">        # Standard variants</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;A&#39;, &#39;G&#39;)</span>
<span class="sd">        &#39;SNV&#39;</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;AGG&#39;, &#39;TCG&#39;)</span>
<span class="sd">        &#39;MNV&#39;</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;T&#39;, &#39;TGGG&#39;)</span>
<span class="sd">        &#39;INS&#39;</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;CGAGAA&#39;, &#39;C&#39;)</span>
<span class="sd">        &#39;DEL&#39;</span>

<span class="sd">        # Structural variants</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;N&#39;, &#39;&lt;INV&gt;&#39;)</span>
<span class="sd">        &#39;SV_INV&#39;</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;G&#39;, &#39;G]17:198982]&#39;)</span>
<span class="sd">        &#39;SV_BND&#39;</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;T&#39;, &#39;]chr2:20]ATCGT&#39;)</span>
<span class="sd">        &#39;SV_BND_INS&#39;</span>

<span class="sd">        # Special cases</span>
<span class="sd">        &gt;&gt;&gt; classify_variant_type(&#39;T&#39;, &#39;*&#39;)</span>
<span class="sd">        &#39;missing&#39;</span>

<span class="sd">    VCF 4.2 Reference: https://samtools.github.io/hts-specs/VCFv4.2.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_allele</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">alt_allele</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;missing_ref_or_alt&quot;</span>

    <span class="c1"># Normalize alleles (VCF allows mixed case)</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">ref_allele</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">alt</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="c1"># PRIORITY 0: Multiallelic variants (comma-separated ALT alleles)</span>
    <span class="c1"># Multiple alternative alleles in single ALT field indicate complex variant</span>
    <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">alt</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;multiallelic&quot;</span>

    <span class="c1"># PRIORITY 1: Handle missing/upstream deletion alleles</span>
    <span class="c1"># The &#39;*&#39; allele indicates missing due to upstream deletion (VCF 4.2 spec)</span>
    <span class="k">if</span> <span class="n">alt</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;missing&quot;</span>

    <span class="c1"># PRIORITY 2: Structural variants with symbolic alleles</span>
    <span class="c1"># Format: &lt;ID&gt; where ID indicates structural variant type</span>
    <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">alt</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">):</span>
        <span class="n">sv_type</span> <span class="o">=</span> <span class="n">alt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>  <span class="c1"># Extract type from &lt;INV&gt;, &lt;DUP&gt;, etc.</span>

        <span class="c1"># Map symbolic alleles to standard classifications</span>
        <span class="k">if</span> <span class="n">sv_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;INV&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_INV&quot;</span>
        <span class="k">elif</span> <span class="n">sv_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;DUP:TANDEM&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_DUP&quot;</span>
        <span class="k">elif</span> <span class="n">sv_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;DEL&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_DEL&quot;</span>
        <span class="k">elif</span> <span class="n">sv_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;INS&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_INS&quot;</span>
        <span class="k">elif</span> <span class="n">sv_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CNV&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_CNV&quot;</span>
        <span class="k">elif</span> <span class="n">sv_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;BND&quot;</span><span class="p">,</span> <span class="s2">&quot;TRA&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_BND&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback to returning the ALT</span>
            <span class="k">return</span> <span class="n">alt</span>

    <span class="c1"># PRIORITY 3: Breakend notation (complex rearrangements)</span>
    <span class="c1"># Format examples: A[chr2:1000[, ]chr1:100]T, etc.</span>
    <span class="n">breakend_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[\[\]]&quot;</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">breakend_pattern</span><span class="p">,</span> <span class="n">alt</span><span class="p">):</span>
        <span class="c1"># Check if BND has inserted sequence by parsing the ALT field</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">breakend_info</span> <span class="o">=</span> <span class="n">parse_breakend_alt</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">breakend_info</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">breakend_info</span><span class="p">[</span><span class="s2">&quot;inserted_seq&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s2">&quot;SV_BND_INS&quot;</span>  <span class="c1"># BND with insertion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;SV_BND&quot;</span>  <span class="c1"># Standard BND</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># If parsing fails, fallback to returning the ALT</span>
            <span class="k">return</span> <span class="n">alt</span>

    <span class="c1"># PRIORITY 4: Check SVTYPE in INFO field for additional SV classification</span>
    <span class="c1"># Note: Symbolic ALT fields (&lt;INV&gt;, &lt;DUP&gt;) are handled by priority 3, so this mainly</span>
    <span class="c1"># serves as fallback for non-standard VCF files</span>
    <span class="k">if</span> <span class="n">info_dict</span> <span class="ow">and</span> <span class="s2">&quot;SVTYPE&quot;</span> <span class="ow">in</span> <span class="n">info_dict</span><span class="p">:</span>
        <span class="n">svtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s2">&quot;SVTYPE&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">svtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;INV&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_INV&quot;</span>
        <span class="k">elif</span> <span class="n">svtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;DUP&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_DUP&quot;</span>
        <span class="k">elif</span> <span class="n">svtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;DEL&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_DEL&quot;</span>
        <span class="k">elif</span> <span class="n">svtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;INS&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_INS&quot;</span>
        <span class="k">elif</span> <span class="n">svtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CNV&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_CNV&quot;</span>
        <span class="k">elif</span> <span class="n">svtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;BND&quot;</span><span class="p">,</span> <span class="s2">&quot;TRA&quot;</span><span class="p">,</span> <span class="s2">&quot;TRANSLOCATION&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;SV_BND&quot;</span>

    <span class="c1"># PRIORITY 5: Standard sequence variants based on length comparison</span>
    <span class="n">ref_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    <span class="n">alt_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref_len</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">alt_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Single base substitution</span>
        <span class="k">if</span> <span class="n">ref</span> <span class="o">!=</span> <span class="n">alt</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;SNV&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Identical alleles - should not occur in valid VCF</span>
            <span class="k">return</span> <span class="n">alt</span>

    <span class="k">elif</span> <span class="n">ref_len</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">alt_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Potential insertion: check if REF is prefix of ALT</span>
        <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;INS&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># REF not a prefix - complex variant</span>
            <span class="k">return</span> <span class="n">alt</span>

    <span class="k">elif</span> <span class="n">ref_len</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">alt_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Potential deletion: check if ALT is prefix of REF</span>
        <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">alt</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;DEL&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ALT not a prefix - complex variant</span>
            <span class="k">return</span> <span class="n">alt</span>

    <span class="k">elif</span> <span class="n">ref_len</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">alt_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Multi-base variant - determine if complex substitution or indel</span>
        <span class="c1"># Check for shared prefix/suffix to identify indel vs substitution</span>

        <span class="c1"># Find longest common prefix</span>
        <span class="n">prefix_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_len</span><span class="p">,</span> <span class="n">alt_len</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">prefix_len</span> <span class="o">&lt;</span> <span class="n">min_len</span> <span class="ow">and</span> <span class="n">ref</span><span class="p">[</span><span class="n">prefix_len</span><span class="p">]</span> <span class="o">==</span> <span class="n">alt</span><span class="p">[</span><span class="n">prefix_len</span><span class="p">]:</span>
            <span class="n">prefix_len</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Find longest common suffix</span>
        <span class="n">suffix_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="n">suffix_len</span> <span class="o">&lt;</span> <span class="n">min_len</span> <span class="o">-</span> <span class="n">prefix_len</span>
            <span class="ow">and</span> <span class="n">ref</span><span class="p">[</span><span class="n">ref_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">suffix_len</span><span class="p">]</span> <span class="o">==</span> <span class="n">alt</span><span class="p">[</span><span class="n">alt_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">suffix_len</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">suffix_len</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Analyze the variant structure</span>
        <span class="k">if</span> <span class="n">prefix_len</span> <span class="o">+</span> <span class="n">suffix_len</span> <span class="o">&gt;=</span> <span class="n">min_len</span><span class="p">:</span>
            <span class="c1"># Significant overlap - likely indel</span>
            <span class="k">if</span> <span class="n">ref_len</span> <span class="o">&gt;</span> <span class="n">alt_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;DEL&quot;</span>
            <span class="k">elif</span> <span class="n">alt_len</span> <span class="o">&gt;</span> <span class="n">ref_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;INS&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Same length with shared prefix/suffix - substitution</span>
                <span class="k">return</span> <span class="n">alt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Limited overlap - substitution</span>
            <span class="k">return</span> <span class="s2">&quot;MNV&quot;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Not parsed - should not occur in valid VCF</span>
        <span class="k">return</span> <span class="n">alt</span></div>



<div class="viewcode-block" id="parse_breakend_alt">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.parse_breakend_alt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_breakend_alt</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse breakend ALT field to extract mate information and inserted sequence.</span>

<span class="sd">    Args:</span>
<span class="sd">        alt_allele: ALT field from BND variant (e.g., &quot;G]17:198982]&quot;, &quot;]13:123456]AGTNNNNNCAT&quot;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Parsed breakend information with keys:</span>
<span class="sd">            - &#39;mate_chrom&#39;: Chromosome of mate breakend</span>
<span class="sd">            - &#39;mate_pos&#39;: Position of mate breakend (1-based)</span>
<span class="sd">            - &#39;orientation&#39;: Breakend orientation (&#39;t[p[&#39;, &#39;t]p]&#39;, &#39;]p]t&#39;, &#39;[p[t&#39;)</span>
<span class="sd">            - &#39;inserted_seq&#39;: Novel sequence inserted at junction (empty string if none)</span>
<span class="sd">            - &#39;is_valid&#39;: Boolean indicating if ALT field was successfully parsed</span>

<span class="sd">    Breakend ALT format examples (VCF 4.2):</span>

<span class="sd">        - t[p[: piece extending to the right of p is joined after t</span>
<span class="sd">        - t]p]: reverse comp piece extending left of p is joined after t</span>
<span class="sd">        - ]p]t: piece extending to the left of p is joined before t</span>
<span class="sd">        - [p[t: reverse comp piece extending right of p is joined before t</span>

<span class="sd">    Examples:</span>

<span class="sd">        &gt;&gt;&gt; parse_breakend_alt(&quot;G]17:198982]&quot;)</span>
<span class="sd">        {&#39;mate_chrom&#39;: &#39;17&#39;, &#39;mate_pos&#39;: 198982, &#39;orientation&#39;: &#39;t]p]&#39;,</span>
<span class="sd">         &#39;inserted_seq&#39;: &#39;&#39;, &#39;is_valid&#39;: True}</span>

<span class="sd">        &gt;&gt;&gt; parse_breakend_alt(&quot;]13:123456]AGTNNNNNCAT&quot;)</span>
<span class="sd">        {&#39;mate_chrom&#39;: &#39;13&#39;, &#39;mate_pos&#39;: 123456, &#39;orientation&#39;: &#39;]p]t&#39;,</span>
<span class="sd">         &#39;inserted_seq&#39;: &#39;AGTNNNNNCAT&#39;, &#39;is_valid&#39;: True}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;mate_chrom&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;mate_pos&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;orientation&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;inserted_seq&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_valid&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">alt_allele</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># Patterns for the four breakend orientations</span>
    <span class="c1"># t[p[ format: sequence + [ + position + [</span>
    <span class="n">pattern1</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^(.+?)\[([^:]+):(\d+)\[$&quot;</span>
    <span class="c1"># t]p] format: sequence + ] + position + ]</span>
    <span class="n">pattern2</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^(.+?)\]([^:]+):(\d+)\]$&quot;</span>
    <span class="c1"># ]p]t format: ] + position + ] + sequence</span>
    <span class="n">pattern3</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^\]([^:]+):(\d+)\](.+?)$&quot;</span>
    <span class="c1"># [p[t format: [ + position + [ + sequence</span>
    <span class="n">pattern4</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^\[([^:]+):(\d+)\[(.+?)$&quot;</span>

    <span class="c1"># Try each pattern</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern1</span><span class="p">,</span> <span class="n">alt_allele</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">prefix_seq</span><span class="p">,</span> <span class="n">mate_chrom</span><span class="p">,</span> <span class="n">mate_pos</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mate_chrom</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mate_pos</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;t[p[&quot;</span>  <span class="c1"># t[p[</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;inserted_seq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">prefix_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>  <span class="c1"># Remove reference base</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern2</span><span class="p">,</span> <span class="n">alt_allele</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">prefix_seq</span><span class="p">,</span> <span class="n">mate_chrom</span><span class="p">,</span> <span class="n">mate_pos</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mate_chrom</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mate_pos</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;t]p]&quot;</span>  <span class="c1"># t]p]</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;inserted_seq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">prefix_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>  <span class="c1"># Remove reference base</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern3</span><span class="p">,</span> <span class="n">alt_allele</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">mate_chrom</span><span class="p">,</span> <span class="n">mate_pos</span><span class="p">,</span> <span class="n">suffix_seq</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mate_chrom</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mate_pos</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;]p]t&quot;</span>  <span class="c1"># ]p]t</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;inserted_seq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">suffix_seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffix_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>  <span class="c1"># Remove reference base</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern4</span><span class="p">,</span> <span class="n">alt_allele</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">mate_chrom</span><span class="p">,</span> <span class="n">mate_pos</span><span class="p">,</span> <span class="n">suffix_seq</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mate_chrom</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mate_pos</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;[p[t&quot;</span>  <span class="c1"># [p[t</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;inserted_seq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">suffix_seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffix_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>  <span class="c1"># Remove reference base</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="validate_breakend_pair">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.validate_breakend_pair">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_breakend_pair</span><span class="p">(</span><span class="n">bnd1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">bnd2</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate that two breakend variants form a consistent mate pair.</span>

<span class="sd">    Args:</span>
<span class="sd">        bnd1: First breakend variant (dict with id, mate_id, chrom, pos, etc.)</span>
<span class="sd">        bnd2: Second breakend variant (dict with id, mate_id, chrom, pos, etc.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Validation result with keys:</span>
<span class="sd">            - &#39;is_valid&#39;: Boolean indicating if pair is valid</span>
<span class="sd">            - &#39;errors&#39;: List of validation error messages</span>
<span class="sd">            - &#39;warnings&#39;: List of validation warning messages</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;is_valid&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;errors&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;warnings&quot;</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="c1"># Check that they reference each other as mates</span>
    <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mate_id&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;errors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;BND </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> MATEID </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mate_id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match mate ID </span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mate_id&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;errors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;BND </span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> MATEID </span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mate_id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match mate ID </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Check that mate positions are consistent with actual positions</span>
    <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chrom&quot;</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;errors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;BND </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> mate chromosome </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mate_chrom&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match actual chromosome </span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;chrom&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pos&quot;</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;errors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;BND </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> mate position </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mate_pos&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match actual position </span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pos&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Check orientation consistency (complex logic depending on rearrangement type)</span>
    <span class="n">orientation1</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;orientation&quot;</span><span class="p">)</span>
    <span class="n">orientation2</span> <span class="o">=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;orientation&quot;</span><span class="p">)</span>

    <span class="c1"># For now, just warn about complex orientation validation - this would need detailed implementation</span>
    <span class="k">if</span> <span class="n">orientation1</span> <span class="ow">and</span> <span class="n">orientation2</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;warnings&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Orientation validation not fully implemented: </span><span class="si">{</span><span class="n">orientation1</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">orientation2</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="create_breakend_pairs">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.create_breakend_pairs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_breakend_pairs</span><span class="p">(</span><span class="n">variants_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">BreakendPair</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create BreakendPair objects from BND variants in a DataFrame.</span>

<span class="sd">    This function pairs breakend variants based on coordinate matching rather than MATEID,</span>
<span class="sd">    making it more robust and not dependent on optional INFO fields.</span>

<span class="sd">    Args:</span>
<span class="sd">        variants_df: DataFrame containing BND variants with variant_type=&#39;SV_BND&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of BreakendPair objects representing valid breakend pairs</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Pairs breakends by matching coordinates from ALT field parsing</span>
<span class="sd">        - Does not require MATEID field to be present</span>
<span class="sd">        - Issues warnings for unpaired or invalid breakends</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Filter for BND variants only (including BND with insertions)</span>
    <span class="n">bnd_variants</span> <span class="o">=</span> <span class="n">variants_df</span><span class="p">[</span>
        <span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INS&quot;</span><span class="p">])</span>
    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_variants</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Parse all breakend variants</span>
    <span class="n">breakend_variants</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">bnd_variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Parse ALT field to get mate information</span>
            <span class="n">breakend_info</span> <span class="o">=</span> <span class="n">parse_breakend_alt</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">breakend_info</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not parse breakend ALT field for variant </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Parse INFO field for optional MATEID (but don&#39;t require it)</span>
            <span class="n">info_dict</span> <span class="o">=</span> <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
            <span class="n">mate_id</span> <span class="o">=</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;MATEID&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Create BreakendVariant object</span>
            <span class="n">breakend</span> <span class="o">=</span> <span class="n">BreakendVariant</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
                <span class="n">chrom</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">],</span>
                <span class="n">pos</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">],</span>
                <span class="n">ref</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">],</span>
                <span class="n">alt</span><span class="o">=</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">],</span>
                <span class="n">mate_id</span><span class="o">=</span><span class="n">mate_id</span><span class="p">,</span>  <span class="c1"># May be None</span>
                <span class="n">mate_chrom</span><span class="o">=</span><span class="n">breakend_info</span><span class="p">[</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">],</span>
                <span class="n">mate_pos</span><span class="o">=</span><span class="n">breakend_info</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">],</span>
                <span class="n">orientation</span><span class="o">=</span><span class="n">breakend_info</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">],</span>
                <span class="n">inserted_seq</span><span class="o">=</span><span class="n">breakend_info</span><span class="p">[</span><span class="s2">&quot;inserted_seq&quot;</span><span class="p">],</span>
                <span class="n">info</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                <span class="n">variant_type</span><span class="o">=</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">breakend_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">breakend</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing breakend variant </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

    <span class="c1"># Create pairs by coordinate matching</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">used_breakends</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bnd1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">breakend_variants</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">used_breakends</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Find mate by coordinate matching</span>
        <span class="n">mate_found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bnd2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">breakend_variants</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">used_breakends</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Check if these breakends are mates based on coordinates</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">bnd1</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span>
                <span class="ow">and</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">mate_pos</span> <span class="o">==</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span>
                <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">==</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span>
                <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">mate_pos</span> <span class="o">==</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span>
            <span class="p">):</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Create pair (validation happens in BreakendPair.__post_init__)</span>
                    <span class="n">pair</span> <span class="o">=</span> <span class="n">BreakendPair</span><span class="p">(</span><span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span><span class="p">)</span>
                    <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                    <span class="n">used_breakends</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="n">used_breakends</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bnd2</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="n">mate_found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid breakend pair </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mate_found</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No mate found for breakend </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">pairs</span></div>



<div class="viewcode-block" id="load_breakend_variants">
<a class="viewcode-back" href="../../autoapi/supremo_lite/variant_utils/index.html#supremo_lite.load_breakend_variants">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_breakend_variants</span><span class="p">(</span>
    <span class="n">variants_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load variants and separate BND variants into pairs using enhanced classifier.</span>

<span class="sd">    Args:</span>
<span class="sd">        variants_fn: Path to VCF file or DataFrame with variant data</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (standard_variants_df, breakend_pairs_list)</span>
<span class="sd">        - standard_variants_df: DataFrame with non-BND variants</span>
<span class="sd">        - breakend_pairs_list: List of tuples (bnd1, bnd2) for BND pairs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Import here to avoid circular imports</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.personalize</span><span class="w"> </span><span class="kn">import</span> <span class="n">_load_variants</span>

    <span class="c1"># Load all variants with proper normalization and classification</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">all_variants</span> <span class="o">=</span> <span class="n">read_vcf</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">,</span> <span class="n">include_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">classify_variants</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vcf_path</span> <span class="o">=</span> <span class="n">variants_fn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Use the existing _load_variants function which properly handles</span>
        <span class="c1"># DataFrame normalization (pos-&gt;pos1, variant_type, etc.)</span>
        <span class="n">all_variants</span> <span class="o">=</span> <span class="n">_load_variants</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">)</span>
        <span class="n">vcf_path</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Separate BND and standard variants (including all BND types)</span>
    <span class="n">bnd_variants</span> <span class="o">=</span> <span class="n">all_variants</span><span class="p">[</span>
        <span class="n">all_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INS&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INV&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">]</span>
    <span class="n">standard_variants</span> <span class="o">=</span> <span class="n">all_variants</span><span class="p">[</span>
        <span class="o">~</span><span class="n">all_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INS&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INV&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Create breakend pairs using enhanced classifier</span>
    <span class="n">breakend_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vcf_path</span><span class="p">:</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">BNDClassifier</span><span class="p">()</span>
        <span class="n">classified_breakends</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">classify_all_breakends</span><span class="p">(</span>
            <span class="n">vcf_path</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># Convert classified breakends to pairs</span>
        <span class="n">paired_breakends</span> <span class="o">=</span> <span class="n">classified_breakends</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span>
        <span class="n">processed_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">breakend</span> <span class="ow">in</span> <span class="n">paired_breakends</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">breakend</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span><span class="p">:</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">breakend</span><span class="p">,</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span><span class="p">)</span>
                <span class="n">breakend_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">standard_variants</span><span class="p">,</span> <span class="n">breakend_pairs</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_filter_multiallelic_variants</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter out variants with multiallelic ALT fields (containing commas).</span>

<span class="sd">    Args:</span>
<span class="sd">        df: DataFrame with variant data including &#39;alt&#39; column</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with multiallelic variants removed</span>

<span class="sd">    Notes:</span>
<span class="sd">        Issues a warning when multiallelic variants are found and removed.</span>
<span class="sd">        Multiallelic variants have ALT fields like &quot;G,T&quot; indicating multiple</span>
<span class="sd">        alternative alleles at the same position.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;alt&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="c1"># Identify multiallelic variants (ALT field contains comma)</span>
    <span class="n">multiallelic_mask</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">n_multiallelic</span> <span class="o">=</span> <span class="n">multiallelic_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n_multiallelic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">n_multiallelic</span><span class="si">}</span><span class="s2"> multiallelic variants with comma-separated ALT alleles. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;These variants have been removed from the dataset. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Consider preprocessing your VCF file to split multiallelic sites if needed.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Filter out multiallelic variants</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">multiallelic_mask</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Gladstone Institutes.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>