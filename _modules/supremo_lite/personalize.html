

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>supremo_lite.personalize &mdash; supremo_lite  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            supremo_lite
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/personalization.html">Personalized Genome Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/variant_centered_sequences.html">Variant-Centered Sequence Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/pam_disruption.html">PAM Disruption Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/prediction_alignment.html">Prediction Alignment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/prediction_alignment_examples.html">Prediction Alignment Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/prediction_alignment_examples.html#variant-type-examples">Variant Type Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/mutagenesis.html">Saturation Mutagenesis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/01_getting_started.html">Getting Started with supremo_lite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/02_personalized_genomes.html">Personalized Genome Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/03_prediction_alignment.html">Prediction Alignment: From Sequences to Aligned Predictions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/04_pam_disruption.html">PAM Disruption Analysis: Identifying CRISPR-Resistant Variants</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conduct.html">Code of Conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">supremo_lite</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">supremo_lite.personalize</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for supremo_lite.personalize</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Personalized sequence generation for supremo_lite.</span>

<span class="sd">This module provides functions for creating personalized genomes by applying</span>
<span class="sd">variants to a reference genome and generating sequence windows around variants.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">bisect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">NamedTuple</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyfaidx</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fasta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">read_vcf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.chromosome_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">match_chromosomes_with_report</span><span class="p">,</span> <span class="n">apply_chromosome_mapping</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.sequence_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">encode_seq</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">TORCH_AVAILABLE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">classify_variant_type</span><span class="p">,</span> <span class="n">parse_vcf_info</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># Already handled in core</span>


<span class="c1"># IUPAC degenerate nucleotide codes for PAM pattern matching</span>
<span class="n">IUPAC_CODES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
    <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span>
    <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
    <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="s2">&quot;U&quot;</span><span class="p">,</span>
    <span class="s2">&quot;W&quot;</span><span class="p">:</span> <span class="s2">&quot;[AT]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="s2">&quot;[CG]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="s2">&quot;[AC]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;K&quot;</span><span class="p">:</span> <span class="s2">&quot;[GT]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="s2">&quot;[AG]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="s2">&quot;[CT]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="s2">&quot;[CGT]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="s2">&quot;[AGT]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="s2">&quot;[ACT]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="s2">&quot;[ACG]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;[ACGT]&quot;</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="ChromosomeOffsetTracker">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChromosomeOffsetTracker">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ChromosomeOffsetTracker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tracks cumulative coordinate offsets per chromosome from applied variants.</span>

<span class="sd">    When standard variants (INS/DEL) change chromosome lengths, the original VCF</span>
<span class="sd">    coordinates for later BND variants become invalid. This class tracks the</span>
<span class="sd">    cumulative offset at each position to enable coordinate transformation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize empty offset tracker.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chromosome_offsets</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{}</span>
        <span class="p">)</span>  <span class="c1"># chrom -&gt; [(pos, cumulative_offset)]</span>

<div class="viewcode-block" id="ChromosomeOffsetTracker.add_offset">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChromosomeOffsetTracker.add_offset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an offset at a specific position on a chromosome.</span>

<span class="sd">        Args:</span>
<span class="sd">            chrom: Chromosome name</span>
<span class="sd">            pos: Genomic position (0-based) where offset occurs</span>
<span class="sd">            offset: Length change (+/- bases) from the variant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromosome_offsets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chromosome_offsets</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Find insertion point and update cumulative offsets</span>
        <span class="n">offset_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromosome_offsets</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span>

        <span class="c1"># Calculate cumulative offset at this position</span>
        <span class="n">cumulative_offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">for</span> <span class="n">existing_pos</span><span class="p">,</span> <span class="n">existing_cumulative</span> <span class="ow">in</span> <span class="n">offset_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">existing_pos</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">cumulative_offset</span> <span class="o">+=</span> <span class="n">existing_cumulative</span>

        <span class="c1"># Insert new offset entry, maintaining sorted order by position</span>
        <span class="n">inserted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">existing_pos</span><span class="p">,</span> <span class="n">existing_cumulative</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">offset_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">existing_pos</span><span class="p">:</span>
                <span class="n">offset_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">cumulative_offset</span><span class="p">))</span>
                <span class="n">inserted</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Update all downstream offsets</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_list</span><span class="p">)):</span>
                    <span class="n">old_pos</span><span class="p">,</span> <span class="n">old_cumulative</span> <span class="o">=</span> <span class="n">offset_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">offset_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_pos</span><span class="p">,</span> <span class="n">old_cumulative</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inserted</span><span class="p">:</span>
            <span class="n">offset_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">cumulative_offset</span><span class="p">))</span></div>


<div class="viewcode-block" id="ChromosomeOffsetTracker.get_offset_at_position">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChromosomeOffsetTracker.get_offset_at_position">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_offset_at_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the cumulative offset at a specific position.</span>

<span class="sd">        Args:</span>
<span class="sd">            chrom: Chromosome name</span>
<span class="sd">            pos: Genomic position (0-based) to query</span>

<span class="sd">        Returns:</span>
<span class="sd">            Cumulative offset at this position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromosome_offsets</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">offset_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromosome_offsets</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span>
        <span class="n">cumulative_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">offset_pos</span><span class="p">,</span> <span class="n">offset_cumulative</span> <span class="ow">in</span> <span class="n">offset_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">offset_pos</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">cumulative_offset</span> <span class="o">=</span> <span class="n">offset_cumulative</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">cumulative_offset</span></div>


<div class="viewcode-block" id="ChromosomeOffsetTracker.transform_coordinate">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChromosomeOffsetTracker.transform_coordinate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a VCF coordinate to account for applied variants.</span>

<span class="sd">        Args:</span>
<span class="sd">            chrom: Chromosome name</span>
<span class="sd">            pos: Original VCF position (1-based)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Transformed position (1-based) in the modified sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert to 0-based, apply offset, convert back to 1-based</span>
        <span class="n">pos_0based</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_at_position</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos_0based</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">offset</span></div>
</div>



<div class="viewcode-block" id="SequenceSegment">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.SequenceSegment">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SequenceSegment</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a segment within a sequence with its source and position.&quot;&quot;&quot;</span>

    <span class="n">source_type</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># &#39;reference&#39;, &#39;novel&#39;, &#39;rc_reference&#39;</span>
    <span class="n">source_chrom</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># chromosome name or &#39;NOVEL&#39;</span>
    <span class="n">start_pos</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># start position in the final sequence</span>
    <span class="n">end_pos</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># end position in the final sequence</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># segment length</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># &#39;forward&#39;, &#39;reverse&#39;, &#39;novel&#39;</span></div>



<div class="viewcode-block" id="FrozenRegionTracker">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.FrozenRegionTracker">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FrozenRegionTracker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Efficiently tracks genomic regions that are &#39;frozen&#39; due to applied variants.</span>

<span class="sd">    Frozen regions prevent overlapping variants from being applied to the same</span>
<span class="sd">    genomic coordinates. Uses a sorted list of non-overlapping intervals with</span>
<span class="sd">    binary search for lookup.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize empty interval tracker.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># sorted list of (start, end) tuples</span>

<div class="viewcode-block" id="FrozenRegionTracker.is_frozen">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.FrozenRegionTracker.is_frozen">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a genomic position is within any frozen region.</span>

<span class="sd">        Args:</span>
<span class="sd">            pos: Genomic position (0-based)</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if position is frozen, False otherwise</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Binary search for interval that could contain pos</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">end</span>

        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="FrozenRegionTracker.add_range">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.FrozenRegionTracker.add_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new frozen region, merging with existing overlapping intervals.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: Start position of region (0-based, inclusive)</span>
<span class="sd">            end: End position of region (0-based, inclusive)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Find insertion point and overlapping intervals</span>
        <span class="n">left_idx</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
        <span class="n">right_idx</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>

        <span class="c1"># Check for overlap with interval before insertion point</span>
        <span class="k">if</span> <span class="n">left_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prev_start</span><span class="p">,</span> <span class="n">prev_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">left_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prev_end</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Adjacent or overlapping</span>
                <span class="n">left_idx</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">prev_start</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">)</span>

        <span class="c1"># Merge with all overlapping intervals</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">right_idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">))):</span>
            <span class="n">interval_start</span><span class="p">,</span> <span class="n">interval_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">interval_start</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Adjacent or overlapping</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">interval_start</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">interval_end</span><span class="p">)</span>

        <span class="c1"># Remove old intervals and insert merged interval</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">left_idx</span><span class="p">:</span><span class="n">right_idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="ChromosomeSegmentTracker">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChromosomeSegmentTracker">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ChromosomeSegmentTracker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Track which segments of each chromosome are used by fusions.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_sequences</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_sequences</span> <span class="o">=</span> <span class="n">ref_sequences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used_segments</span> <span class="o">=</span> <span class="p">{</span><span class="n">chrom</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">ref_sequences</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

<div class="viewcode-block" id="ChromosomeSegmentTracker.add_used_segment">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChromosomeSegmentTracker.add_used_segment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_used_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a used segment (0-based coordinates).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_segments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">used_segments</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;   üîç Tracking used segment: </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="si">}</span><span class="s2">bp&quot;</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="ChromosomeSegmentTracker.get_leftover_sequences">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChromosomeSegmentTracker.get_leftover_sequences">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_leftover_sequences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate leftover sequences not used by any fusion.&quot;&quot;&quot;</span>
        <span class="n">leftover_sequences</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">ref_seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_sequences</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">used_segments</span><span class="p">[</span><span class="n">chrom</span><span class="p">])</span>
            <span class="n">leftover_parts</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">segments</span><span class="p">:</span>
                <span class="c1"># No segments used - entire chromosome is leftover</span>
                <span class="n">leftover_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_seq</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Find gaps between used segments</span>
                <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
                    <span class="c1"># Add leftover before this segment</span>
                    <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                        <span class="n">leftover_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">[</span><span class="n">current_pos</span><span class="p">:</span><span class="n">start</span><span class="p">])</span>
                    <span class="n">current_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

                <span class="c1"># Add leftover after last segment</span>
                <span class="k">if</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">):</span>
                    <span class="n">leftover_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">[</span><span class="n">current_pos</span><span class="p">:])</span>

            <span class="c1"># Combine leftover parts</span>
            <span class="k">if</span> <span class="n">leftover_parts</span><span class="p">:</span>
                <span class="n">leftover_seq</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">leftover_parts</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">leftover_seq</span><span class="p">:</span>  <span class="c1"># Only add non-empty leftovers</span>
                    <span class="n">leftover_sequences</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">leftover_seq</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ‚úÇÔ∏è Created leftover </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">leftover_seq</span><span class="p">)</span><span class="si">}</span><span class="s2"> bp&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">leftover_sequences</span></div>
</div>



<div class="viewcode-block" id="VariantApplicator">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.VariantApplicator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VariantApplicator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies VCF variants to a reference sequence in memory.</span>

<span class="sd">    Handles coordinate system transformations, frozen region tracking,</span>
<span class="sd">    and sequence modifications for SNVs, insertions, and deletions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sequence_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">variants_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">frozen_tracker</span><span class="p">:</span> <span class="n">FrozenRegionTracker</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset_tracker</span><span class="p">:</span> <span class="n">ChromosomeOffsetTracker</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize variant applicator for a single chromosome.</span>

<span class="sd">        Args:</span>
<span class="sd">            sequence_str: Reference sequence as string</span>
<span class="sd">            variants_df: DataFrame containing variants for this chromosome</span>
<span class="sd">            frozen_tracker: Optional existing FrozenRegionTracker to preserve overlap state across chunks</span>
<span class="sd">            offset_tracker: Optional ChromosomeOffsetTracker to track coordinate offsets</span>
<span class="sd">            chrom: Chromosome name (required if offset_tracker is provided)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">sequence_str</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>  <span class="c1"># Mutable sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variants</span> <span class="o">=</span> <span class="n">variants_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;pos1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frozen_tracker</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">frozen_tracker</span> <span class="k">if</span> <span class="n">frozen_tracker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">FrozenRegionTracker</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset_tracker</span> <span class="o">=</span> <span class="n">offset_tracker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">chrom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_offset</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Track length changes from applied variants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">applied_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># List of (vcf_line, chrom, pos1, ref, alt, reason) tuples</span>

<div class="viewcode-block" id="VariantApplicator.apply_variants">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.VariantApplicator.apply_variants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_variants</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply all variants to the sequence.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple of (modified_sequence, statistics_dict)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_apply_single_variant</span><span class="p">(</span><span class="n">variant</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Extract concise error message and context</span>
                <span class="n">vcf_line</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vcf_line&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
                <span class="n">chrom</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
                <span class="n">error_msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Skipped variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2"> (VCF line </span><span class="si">{</span><span class="n">vcf_line</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">error_msg</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Record skip details for reporting</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">vcf_line</span><span class="p">,</span>
                        <span class="n">chrom</span><span class="p">,</span>
                        <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="p">,</span>
                        <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                        <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                        <span class="s2">&quot;validation_error&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;applied&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">applied_count</span><span class="p">,</span>
            <span class="s2">&quot;skipped&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span><span class="p">,</span>
            <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">),</span>
            <span class="s2">&quot;skipped_variants&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="o">.</span><span class="n">decode</span><span class="p">(),</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="VariantApplicator.apply_single_variant_to_window">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.VariantApplicator.apply_single_variant_to_window">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_single_variant_to_window</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variant</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">window_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">window_end</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a single variant to a sequence window.</span>

<span class="sd">        Args:</span>
<span class="sd">            variant: Series containing variant information (pos, ref, alt)</span>
<span class="sd">            window_start: Start position of window (0-based)</span>
<span class="sd">            window_end: End position of window (0-based, exclusive)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Modified sequence string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a copy of the window sequence</span>
        <span class="n">window_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Handle multiple ALT alleles - take first one</span>
        <span class="n">alt_allele</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Calculate variant position relative to window</span>
        <span class="n">genomic_pos</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert VCF 1-based to 0-based</span>
        <span class="n">var_pos_in_window</span> <span class="o">=</span> <span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">window_start</span>

        <span class="c1"># Check if variant is within window</span>
        <span class="k">if</span> <span class="n">var_pos_in_window</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var_pos_in_window</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">window_seq</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

        <span class="c1"># Check if entire variant fits in window</span>
        <span class="n">ref_end</span> <span class="o">=</span> <span class="n">var_pos_in_window</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ref_end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">window_seq</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

        <span class="c1"># Validate reference matches</span>
        <span class="n">expected_ref</span> <span class="o">=</span> <span class="n">window_seq</span><span class="p">[</span><span class="n">var_pos_in_window</span><span class="p">:</span><span class="n">ref_end</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">expected_ref</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Reference mismatch at position </span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;expected &#39;</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="si">}</span><span class="s2">&#39;, found &#39;</span><span class="si">{</span><span class="n">expected_ref</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">window_seq</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

        <span class="c1"># Apply variant</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
            <span class="c1"># SNV: Direct substitution</span>
            <span class="n">window_seq</span><span class="p">[</span><span class="n">var_pos_in_window</span><span class="p">:</span><span class="n">ref_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
            <span class="c1"># Deletion</span>
            <span class="n">window_seq</span><span class="p">[</span><span class="n">var_pos_in_window</span> <span class="p">:</span> <span class="n">var_pos_in_window</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">del</span> <span class="n">window_seq</span><span class="p">[</span><span class="n">var_pos_in_window</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)</span> <span class="p">:</span> <span class="n">ref_end</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Insertion</span>
            <span class="n">window_seq</span><span class="p">[</span><span class="n">var_pos_in_window</span><span class="p">:</span><span class="n">ref_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">window_seq</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_single_variant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variant</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a single variant to the sequence using variant type classifications.</span>

<span class="sd">        Args:</span>
<span class="sd">            variant: Series containing variant information (pos, ref, alt, variant_type)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. VARIANT TYPE VALIDATION</span>
        <span class="n">variant_type</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variant_type&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">)</span>

        <span class="c1"># Define supported variant types for standard variant processing</span>
        <span class="n">supported_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;SNV&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MNV&quot;</span><span class="p">,</span>
            <span class="s2">&quot;INS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;DEL&quot;</span><span class="p">,</span>
            <span class="s2">&quot;complex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SV_DUP&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SV_INV&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SV_BND_INV&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Handle variants that should be processed elsewhere or are unsupported</span>
        <span class="n">vcf_line</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vcf_line&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
        <span class="n">chrom</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">variant_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SV_BND&quot;</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Skipped variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2"> (VCF line </span><span class="si">{</span><span class="n">vcf_line</span><span class="si">}</span><span class="s2">): type &#39;</span><span class="si">{</span><span class="n">variant_type</span><span class="si">}</span><span class="s2">&#39; not supported&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">vcf_line</span><span class="p">,</span>
                    <span class="n">chrom</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                    <span class="s2">&quot;unsupported_type&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">variant_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;SV_DEL&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_INS&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_CNV&quot;</span><span class="p">}:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Skipped variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2"> (VCF line </span><span class="si">{</span><span class="n">vcf_line</span><span class="si">}</span><span class="s2">): type &#39;</span><span class="si">{</span><span class="n">variant_type</span><span class="si">}</span><span class="s2">&#39; not supported&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">vcf_line</span><span class="p">,</span>
                    <span class="n">chrom</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                    <span class="s2">&quot;unsupported_type&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">variant_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;missing&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">}:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Skipped variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2"> (VCF line </span><span class="si">{</span><span class="n">vcf_line</span><span class="si">}</span><span class="s2">): type &#39;</span><span class="si">{</span><span class="n">variant_type</span><span class="si">}</span><span class="s2">&#39; not supported&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">vcf_line</span><span class="p">,</span>
                    <span class="n">chrom</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                    <span class="s2">&quot;missing_type&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">variant_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_types</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Skipped variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2"> (VCF line </span><span class="si">{</span><span class="n">vcf_line</span><span class="si">}</span><span class="s2">): type &#39;</span><span class="si">{</span><span class="n">variant_type</span><span class="si">}</span><span class="s2">&#39; not supported&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">vcf_line</span><span class="p">,</span>
                    <span class="n">chrom</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                    <span class="s2">&quot;unsupported_type&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># 2. STRUCTURAL VARIANT INFO PARSING</span>
        <span class="n">info_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">variant_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SV_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_INV&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="n">variant</span><span class="p">:</span>
            <span class="n">info_dict</span> <span class="o">=</span> <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">])</span>

        <span class="c1"># 3. BASIC VALIDATION CHECKS</span>
        <span class="k">if</span> <span class="n">variant</span><span class="o">.</span><span class="n">alt</span> <span class="o">==</span> <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span>  <span class="c1"># Skip ref-only variants</span>

        <span class="c1"># Handle multiple ALT alleles - take first one</span>
        <span class="n">alt_allele</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 4. COORDINATE CALCULATION</span>
        <span class="n">genomic_pos</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert VCF 1-based to 0-based</span>
        <span class="n">buffer_pos</span> <span class="o">=</span> <span class="n">genomic_pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_offset</span>

        <span class="c1"># For structural variants, calculate affected region from INFO fields</span>
        <span class="k">if</span> <span class="n">variant_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SV_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_INV&quot;</span><span class="p">]:</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">svlen</span> <span class="o">=</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SVLEN&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Calculate END position if not provided</span>
            <span class="k">if</span> <span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">svlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_pos</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">svlen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Fallback to REF length for structural variants</span>
                <span class="n">end_pos</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot determine structural variant end position for </span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">ref_length</span> <span class="o">=</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Total affected region length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>

        <span class="c1"># 5. FROZEN REGION CHECK</span>
        <span class="n">ref_start</span> <span class="o">=</span> <span class="n">genomic_pos</span>
        <span class="n">ref_end</span> <span class="o">=</span> <span class="n">genomic_pos</span> <span class="o">+</span> <span class="n">ref_length</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frozen_tracker</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span><span class="n">ref_start</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">frozen_tracker</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span>
            <span class="n">ref_end</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Record skip details for reporting</span>
            <span class="n">vcf_line</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vcf_line&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipped_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">vcf_line</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="s2">&quot;overlap&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>  <span class="c1"># Skip overlapping variants</span>

        <span class="c1"># 6. BOUNDS CHECK</span>
        <span class="k">if</span> <span class="n">buffer_pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">buffer_pos</span> <span class="o">+</span> <span class="n">ref_length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variant position </span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2"> out of sequence bounds&quot;</span><span class="p">)</span>

        <span class="c1"># 7. REFERENCE VALIDATION (skip for symbolic structural variants)</span>
        <span class="k">if</span> <span class="n">variant_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SV_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_INV&quot;</span><span class="p">]:</span>
            <span class="n">expected_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span>
                <span class="n">buffer_pos</span> <span class="p">:</span> <span class="n">buffer_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">expected_ref</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Reference mismatch at position </span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">pos1</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;expected &#39;</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="si">}</span><span class="s2">&#39;, found &#39;</span><span class="si">{</span><span class="n">expected_ref</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>

        <span class="c1"># 8. SEQUENCE MODIFICATION</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_modify_sequence</span><span class="p">(</span>
            <span class="n">buffer_pos</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">alt_allele</span><span class="p">,</span> <span class="n">variant_type</span><span class="p">,</span> <span class="n">info_dict</span>
        <span class="p">)</span>

        <span class="c1"># 9. UPDATE TRACKING</span>
        <span class="k">if</span> <span class="n">variant_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SV_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_INV&quot;</span><span class="p">]:</span>
            <span class="c1"># For structural variants, calculate length difference based on variant type</span>
            <span class="k">if</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;SV_DUP&quot;</span><span class="p">:</span>
                <span class="c1"># Duplication adds the duplicated region length</span>
                <span class="n">length_diff</span> <span class="o">=</span> <span class="n">ref_length</span>
            <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;SV_INV&quot;</span><span class="p">:</span>
                <span class="c1"># Inversion doesn&#39;t change sequence length</span>
                <span class="n">length_diff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length_diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_offset</span> <span class="o">+=</span> <span class="n">length_diff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frozen_tracker</span><span class="o">.</span><span class="n">add_range</span><span class="p">(</span><span class="n">ref_start</span><span class="p">,</span> <span class="n">ref_end</span><span class="p">)</span>

        <span class="c1"># Record offset for coordinate transformation if tracker is provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_tracker</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">and</span> <span class="n">length_diff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_tracker</span><span class="o">.</span><span class="n">add_offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">ref_start</span><span class="p">,</span> <span class="n">length_diff</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">applied_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_modify_sequence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ref_allele</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">alt_allele</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">variant_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">info_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify sequence at specified position using variant type classification.</span>

<span class="sd">        Args:</span>
<span class="sd">            pos: Buffer position (0-based)</span>
<span class="sd">            ref_allele: Reference allele sequence</span>
<span class="sd">            alt_allele: Alternate allele sequence</span>
<span class="sd">            variant_type: Classified variant type (SNV, MNV, INS, DEL, complex, SV_DUP, SV_INV)</span>
<span class="sd">            info_dict: Parsed INFO field for structural variants (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Dispatch based on variant type classification</span>
        <span class="k">if</span> <span class="n">variant_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SNV&quot;</span><span class="p">,</span> <span class="s2">&quot;MNV&quot;</span><span class="p">]:</span>
            <span class="c1"># Single or multi-nucleotide substitution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_allele</span><span class="p">)]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;INS&quot;</span><span class="p">:</span>
            <span class="c1"># Insertion: replace reference with longer alternate sequence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_allele</span><span class="p">)]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;DEL&quot;</span><span class="p">:</span>
            <span class="c1"># Deletion: replace reference with shorter alternate sequence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_allele</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;complex&quot;</span><span class="p">:</span>
            <span class="c1"># Complex variant: use length-based logic as fallback</span>
            <span class="n">ref_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_allele</span><span class="p">)</span>
            <span class="n">alt_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">alt_len</span> <span class="o">==</span> <span class="n">ref_len</span><span class="p">:</span>
                <span class="c1"># Same length substitution</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">ref_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">alt_len</span> <span class="o">&lt;</span> <span class="n">ref_len</span><span class="p">:</span>
                <span class="c1"># Deletion-like complex variant</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">alt_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">alt_len</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">ref_len</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Insertion-like complex variant</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">ref_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt_allele</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;SV_DUP&quot;</span><span class="p">:</span>
            <span class="c1"># Tandem duplication: insert duplicated region after original</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">info_dict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;INFO field required for SV_DUP variant&quot;</span><span class="p">)</span>

            <span class="n">end_pos</span> <span class="o">=</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">)</span>

            <span class="c1"># Calculate duplication region using END field only</span>
            <span class="k">if</span> <span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;END field required for SV_DUP variant&quot;</span><span class="p">)</span>

            <span class="c1"># Calculate from buffer position (already offset-adjusted)</span>
            <span class="n">genomic_start</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_allele</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># Position after current cumulative changes</span>
            <span class="n">genomic_end</span> <span class="o">=</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert VCF 1-based to 0-based</span>
            <span class="n">dup_length</span> <span class="o">=</span> <span class="n">genomic_end</span> <span class="o">-</span> <span class="n">genomic_start</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Extract the region to duplicate from current sequence</span>
            <span class="n">duplicated_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">dup_length</span><span class="p">]</span>

            <span class="c1"># Insert duplicated region after original (tandem duplication)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dup_length</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">dup_length</span><span class="p">]</span> <span class="o">=</span> <span class="n">duplicated_region</span>

        <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;SV_INV&quot;</span><span class="p">:</span>
            <span class="c1"># Inversion: reverse complement the affected region</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">info_dict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;INFO field required for SV_INV variant&quot;</span><span class="p">)</span>

            <span class="n">end_pos</span> <span class="o">=</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">)</span>

            <span class="c1"># Calculate inversion region using END field only</span>
            <span class="k">if</span> <span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;END field required for SV_INV variant&quot;</span><span class="p">)</span>

            <span class="c1"># pos is already the correct buffer position (0-based) where inversion starts</span>
            <span class="c1"># END field is 1-based, so convert to 0-based buffer position</span>
            <span class="n">buffer_start</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="n">buffer_end</span> <span class="o">=</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert 1-based END to 0-based</span>
            <span class="n">inv_length</span> <span class="o">=</span> <span class="n">buffer_end</span> <span class="o">-</span> <span class="n">buffer_start</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Extract region to invert</span>
            <span class="n">region_to_invert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span>
                <span class="n">buffer_start</span> <span class="p">:</span> <span class="n">buffer_start</span> <span class="o">+</span> <span class="n">inv_length</span>
            <span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

            <span class="c1"># Apply reverse complement</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.sequence_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">rc_str</span>

            <span class="n">inverted_region</span> <span class="o">=</span> <span class="n">rc_str</span><span class="p">(</span><span class="n">region_to_invert</span><span class="p">)</span>

            <span class="c1"># Replace with inverted sequence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">buffer_start</span> <span class="p">:</span> <span class="n">buffer_start</span> <span class="o">+</span> <span class="n">inv_length</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">inverted_region</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">:</span>
            <span class="c1"># BND-derived tandem duplication</span>
            <span class="c1"># Note: Individual SV_BND_DUP variants should not reach this point as they are</span>
            <span class="c1"># preprocessed by _preprocess_bnd_derived_variants() into synthetic SV_DUP variants</span>
            <span class="n">genomic_pos</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_offset</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>  <span class="c1"># Convert back to 1-based genomic position</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;SV_BND_DUP variants should be preprocessed into SV_DUP variants. Position: </span><span class="si">{</span><span class="n">genomic_pos</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;SV_BND_INV&quot;</span><span class="p">:</span>
            <span class="c1"># BND-derived inversion</span>
            <span class="c1"># Note: Individual SV_BND_INV variants should not reach this point as they are</span>
            <span class="c1"># preprocessed by _preprocess_bnd_derived_variants() into synthetic SV_INV variants</span>
            <span class="n">genomic_pos</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_offset</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>  <span class="c1"># Convert back to 1-based genomic position</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;SV_BND_INV variants should be preprocessed into SV_INV variants. Position: </span><span class="si">{</span><span class="n">genomic_pos</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This should not happen due to validation in _apply_single_variant</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported variant type in sequence modification: </span><span class="si">{</span><span class="n">variant_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>



<div class="viewcode-block" id="ChimericSequenceBuilder">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChimericSequenceBuilder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ChimericSequenceBuilder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builds chimeric sequences from BND rearrangements.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_sequences</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequences</span> <span class="o">=</span> <span class="n">reference_sequences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chimeric_sequences</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_segments</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Store segment metadata for each sequence</span>

<div class="viewcode-block" id="ChimericSequenceBuilder.create_fusion_from_pair">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChimericSequenceBuilder.create_fusion_from_pair">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_fusion_from_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breakend_pair</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create fusion sequence from a pair of breakends.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple of (fusion_name, fusion_sequence)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="o">=</span> <span class="n">breakend_pair</span>

        <span class="c1"># Generate fusion name</span>
        <span class="n">fusion_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="si">}</span><span class="s2">_fusion_</span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Get sequences</span>
        <span class="n">seq1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequences</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">]</span>
        <span class="n">seq2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequences</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">]</span>

        <span class="c1"># Convert VCF 1-based coordinates to 0-based array indices</span>
        <span class="n">pos1_0</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># VCF 1-based -&gt; 0-based array index</span>
        <span class="n">pos2_0</span> <span class="o">=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># VCF 1-based -&gt; 0-based array index</span>

        <span class="c1"># Create fusion based on orientation</span>
        <span class="n">fusion_seq</span><span class="p">,</span> <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_oriented_fusion</span><span class="p">(</span>
            <span class="n">seq1</span><span class="p">,</span>
            <span class="n">pos1_0</span><span class="p">,</span>
            <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
            <span class="n">seq2</span><span class="p">,</span>
            <span class="n">pos2_0</span><span class="p">,</span>
            <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
            <span class="n">bnd1</span><span class="o">.</span><span class="n">inserted_seq</span> <span class="o">+</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">,</span>
            <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
            <span class="n">bnd1</span><span class="p">,</span>
            <span class="n">bnd2</span><span class="p">,</span>  <span class="c1"># Pass original breakends for VCF positions</span>
        <span class="p">)</span>

        <span class="c1"># Store segment metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_segments</span><span class="p">[</span><span class="n">fusion_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">segments</span>

        <span class="k">return</span> <span class="n">fusion_name</span><span class="p">,</span> <span class="n">fusion_seq</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_build_oriented_fusion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">seq1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">pos1_0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">orient1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">seq2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">pos2_0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">orient2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">novel_seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">seq1_chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">seq2_chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">bnd1</span><span class="p">,</span>
        <span class="n">bnd2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">SequenceSegment</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build fusion sequence respecting coordinated breakend pair orientations.</span>

<span class="sd">        Coordinated BND fusion patterns:</span>

<span class="sd">        1. RC Coordination Patterns (require special handling):</span>
<span class="sd">           - [p[t + [p[t : RC(seq2[pos2:]) + seq1[pos1:]</span>
<span class="sd">           - t]p] + t]p] : seq1[:pos1] + RC(seq2[:pos2])</span>

<span class="sd">        2. Same Direction Patterns (simple concatenation):</span>
<span class="sd">           - ]p]t + ]p]t : seq2[:pos2] + seq1[pos1:]</span>
<span class="sd">           - t[p[ + t[p[ : seq1[:pos1] + seq2[pos2:]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.sequence_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">rc_str</span> <span class="k">as</span> <span class="n">reverse_complement</span>

        <span class="c1"># Handle coordinated patterns by looking at both orientations together</span>
        <span class="k">if</span> <span class="n">orient1</span> <span class="o">==</span> <span class="s2">&quot;[p[t&quot;</span> <span class="ow">and</span> <span class="n">orient2</span> <span class="o">==</span> <span class="s2">&quot;[p[t&quot;</span><span class="p">:</span>
            <span class="c1"># [p[t + [p[t pattern: RC(seq2[pos2_0:]) + seq1[pos1_0:]</span>
            <span class="n">left_part</span> <span class="o">=</span> <span class="n">reverse_complement</span><span class="p">(</span><span class="n">seq2</span><span class="p">[</span><span class="n">pos2_0</span><span class="p">:])</span>
            <span class="n">right_part</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[</span><span class="n">pos1_0</span><span class="p">:]</span>
            <span class="n">left_chrom</span> <span class="o">=</span> <span class="n">seq2_chrom</span>
            <span class="n">right_chrom</span> <span class="o">=</span> <span class="n">seq1_chrom</span>
            <span class="n">left_orientation</span> <span class="o">=</span> <span class="s2">&quot;reverse&quot;</span>
            <span class="n">right_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>

        <span class="k">elif</span> <span class="n">orient1</span> <span class="o">==</span> <span class="s2">&quot;t]p]&quot;</span> <span class="ow">and</span> <span class="n">orient2</span> <span class="o">==</span> <span class="s2">&quot;t]p]&quot;</span><span class="p">:</span>
            <span class="c1"># t]p] + t]p] pattern: seq1[:pos1] + RC(seq2[:pos2]) (use VCF positions as base counts)</span>
            <span class="n">left_part</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>  <span class="c1"># Include pos1 bases from seq1</span>
            <span class="n">right_part</span> <span class="o">=</span> <span class="n">reverse_complement</span><span class="p">(</span>
                <span class="n">seq2</span><span class="p">[:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Include pos2 bases from seq2</span>
            <span class="n">left_chrom</span> <span class="o">=</span> <span class="n">seq1_chrom</span>
            <span class="n">right_chrom</span> <span class="o">=</span> <span class="n">seq2_chrom</span>
            <span class="n">left_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>
            <span class="n">right_orientation</span> <span class="o">=</span> <span class="s2">&quot;reverse&quot;</span>

        <span class="k">elif</span> <span class="n">orient1</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span> <span class="ow">and</span> <span class="n">orient2</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span><span class="p">:</span>
            <span class="c1"># ]p]t + ]p]t pattern: seq2[:pos2] + seq1[pos1_0:] (use VCF pos2 as base count)</span>
            <span class="n">left_part</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>  <span class="c1"># Include pos2 bases from seq2</span>
            <span class="n">right_part</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[</span><span class="n">pos1_0</span><span class="p">:]</span>  <span class="c1"># From pos1_0 to end of seq1</span>
            <span class="n">left_chrom</span> <span class="o">=</span> <span class="n">seq2_chrom</span>
            <span class="n">right_chrom</span> <span class="o">=</span> <span class="n">seq1_chrom</span>
            <span class="n">left_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>
            <span class="n">right_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>

        <span class="k">elif</span> <span class="n">orient1</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span> <span class="ow">and</span> <span class="n">orient2</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span><span class="p">:</span>
            <span class="c1"># t[p[ + t[p[ pattern: seq1[:pos1_0] + seq2[pos2_0:]</span>
            <span class="n">left_part</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[:</span><span class="n">pos1_0</span><span class="p">]</span>
            <span class="n">right_part</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">pos2_0</span><span class="p">:]</span>
            <span class="n">left_chrom</span> <span class="o">=</span> <span class="n">seq1_chrom</span>
            <span class="n">right_chrom</span> <span class="o">=</span> <span class="n">seq2_chrom</span>
            <span class="n">left_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>
            <span class="n">right_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>

        <span class="k">elif</span> <span class="n">orient1</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span> <span class="ow">and</span> <span class="n">orient2</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span><span class="p">:</span>
            <span class="c1"># ]p]t + t[p[ pattern: seq2[:pos2] + seq1[pos1_0:] (use VCF pos2 as base count)</span>
            <span class="n">left_part</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>  <span class="c1"># Include pos2 bases from seq2</span>
            <span class="n">right_part</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[</span><span class="n">pos1_0</span><span class="p">:]</span>  <span class="c1"># From pos1_0 to end of seq1</span>
            <span class="n">left_chrom</span> <span class="o">=</span> <span class="n">seq2_chrom</span>
            <span class="n">right_chrom</span> <span class="o">=</span> <span class="n">seq1_chrom</span>
            <span class="n">left_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>
            <span class="n">right_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>

        <span class="k">elif</span> <span class="n">orient1</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span> <span class="ow">and</span> <span class="n">orient2</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span><span class="p">:</span>
            <span class="c1"># t[p[ + ]p]t pattern: seq1[:pos1_0] + seq2[pos2_0:]</span>
            <span class="n">left_part</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[:</span><span class="n">pos1_0</span><span class="p">]</span>
            <span class="n">right_part</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">pos2_0</span><span class="p">:]</span>
            <span class="n">left_chrom</span> <span class="o">=</span> <span class="n">seq1_chrom</span>
            <span class="n">right_chrom</span> <span class="o">=</span> <span class="n">seq2_chrom</span>
            <span class="n">left_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>
            <span class="n">right_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>

        <span class="k">elif</span> <span class="n">orient1</span> <span class="o">==</span> <span class="s2">&quot;t]p]&quot;</span> <span class="ow">and</span> <span class="n">orient2</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span><span class="p">:</span>
            <span class="c1"># t]p] + ]p]t pattern (mixed coordination): seq1[:pos1] + seq2[pos2_0:]</span>
            <span class="n">left_part</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>  <span class="c1"># Include pos1 bases from seq1 (VCF position)</span>
            <span class="n">right_part</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">pos2_0</span><span class="p">:]</span>  <span class="c1"># From pos2_0 to end of seq2</span>
            <span class="n">left_chrom</span> <span class="o">=</span> <span class="n">seq1_chrom</span>
            <span class="n">right_chrom</span> <span class="o">=</span> <span class="n">seq2_chrom</span>
            <span class="n">left_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>
            <span class="n">right_orientation</span> <span class="o">=</span> <span class="s2">&quot;forward&quot;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Unknown orientation pattern - fail fast to ensure proper implementation</span>
            <span class="n">supported_patterns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;[p[t + [p[t (RC coordination)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;t]p] + t]p] (RC coordination)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;]p]t + ]p]t (same direction)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;t[p[ + t[p[ (same direction)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;t]p] + ]p]t (mixed coordination)&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported BND orientation pattern: &#39;</span><span class="si">{</span><span class="n">orient1</span><span class="si">}</span><span class="s2">&#39; + &#39;</span><span class="si">{</span><span class="n">orient2</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Supported patterns: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">supported_patterns</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;This pattern requires explicit implementation.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Build fusion sequence and track segments</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Add left segment</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_part</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">left_type</span> <span class="o">=</span> <span class="s2">&quot;rc_reference&quot;</span> <span class="k">if</span> <span class="n">left_orientation</span> <span class="o">==</span> <span class="s2">&quot;reverse&quot;</span> <span class="k">else</span> <span class="s2">&quot;reference&quot;</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">SequenceSegment</span><span class="p">(</span>
                    <span class="n">source_type</span><span class="o">=</span><span class="n">left_type</span><span class="p">,</span>
                    <span class="n">source_chrom</span><span class="o">=</span><span class="n">left_chrom</span><span class="p">,</span>
                    <span class="n">start_pos</span><span class="o">=</span><span class="n">current_pos</span><span class="p">,</span>
                    <span class="n">end_pos</span><span class="o">=</span><span class="n">current_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_part</span><span class="p">),</span>
                    <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">left_part</span><span class="p">),</span>
                    <span class="n">orientation</span><span class="o">=</span><span class="n">left_orientation</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">current_pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_part</span><span class="p">)</span>

        <span class="c1"># Add novel sequence segment</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">novel_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">SequenceSegment</span><span class="p">(</span>
                    <span class="n">source_type</span><span class="o">=</span><span class="s2">&quot;novel&quot;</span><span class="p">,</span>
                    <span class="n">source_chrom</span><span class="o">=</span><span class="s2">&quot;NOVEL&quot;</span><span class="p">,</span>
                    <span class="n">start_pos</span><span class="o">=</span><span class="n">current_pos</span><span class="p">,</span>
                    <span class="n">end_pos</span><span class="o">=</span><span class="n">current_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">novel_seq</span><span class="p">),</span>
                    <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">novel_seq</span><span class="p">),</span>
                    <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;novel&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">current_pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">novel_seq</span><span class="p">)</span>

        <span class="c1"># Add right segment</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_part</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">right_type</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;rc_reference&quot;</span> <span class="k">if</span> <span class="n">right_orientation</span> <span class="o">==</span> <span class="s2">&quot;reverse&quot;</span> <span class="k">else</span> <span class="s2">&quot;reference&quot;</span>
            <span class="p">)</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">SequenceSegment</span><span class="p">(</span>
                    <span class="n">source_type</span><span class="o">=</span><span class="n">right_type</span><span class="p">,</span>
                    <span class="n">source_chrom</span><span class="o">=</span><span class="n">right_chrom</span><span class="p">,</span>
                    <span class="n">start_pos</span><span class="o">=</span><span class="n">current_pos</span><span class="p">,</span>
                    <span class="n">end_pos</span><span class="o">=</span><span class="n">current_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_part</span><span class="p">),</span>
                    <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">right_part</span><span class="p">),</span>
                    <span class="n">orientation</span><span class="o">=</span><span class="n">right_orientation</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Combine parts to create fusion sequence</span>
        <span class="n">fusion</span> <span class="o">=</span> <span class="n">left_part</span> <span class="o">+</span> <span class="n">novel_seq</span> <span class="o">+</span> <span class="n">right_part</span>

        <span class="k">return</span> <span class="n">fusion</span><span class="p">,</span> <span class="n">segments</span>

<div class="viewcode-block" id="ChimericSequenceBuilder.get_sequence_segments">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.ChimericSequenceBuilder.get_sequence_segments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sequence_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SequenceSegment</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get segment metadata for a sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_segments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sequence_name</span><span class="p">,</span> <span class="p">[])</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_load_reference</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Fasta</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Fasta</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load reference genome from file or return as-is if already loaded.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Fasta</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reference_fn</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_encode_genome_sequences</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to encode genome sequences for output.&quot;&quot;&quot;</span>
    <span class="n">genome</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">reference</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">seq_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">encode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">encoder</span><span class="p">:</span>
                <span class="n">genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">seq_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">encode_seq</span><span class="p">(</span><span class="n">seq_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_str</span>
    <span class="k">return</span> <span class="n">genome</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_load_variants</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load variants from file or return as-is if already a DataFrame.</span>
<span class="sd">    Ensures variant classification happens once during loading.</span>

<span class="sd">    For DataFrames, assumes position column is either &#39;pos&#39;, &#39;pos1&#39;, or the second column.</span>
<span class="sd">    If DataFrame lacks variant_type column, classification will be added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Always load all variants with classification</span>
        <span class="n">variants_df</span> <span class="o">=</span> <span class="n">read_vcf</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">,</span> <span class="n">classify_variants</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Rename pos to pos1 for consistency</span>

        <span class="k">return</span> <span class="n">variants_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Handle DataFrame input</span>
        <span class="n">variants_df</span> <span class="o">=</span> <span class="n">variants_fn</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Always use second column as pos1, regardless of current name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variants_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Rename second column to pos1 if it&#39;s not already named that</span>
            <span class="k">if</span> <span class="n">variants_df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;pos1&quot;</span><span class="p">:</span>
                <span class="n">new_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">variants_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">new_columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;pos1&quot;</span>
                <span class="n">variants_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">new_columns</span>

            <span class="c1"># Validate that pos1 column is numeric</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Position column (second column) must be numeric, got </span><span class="si">{</span><span class="n">variants_df</span><span class="p">[</span><span class="s1">&#39;pos1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;DataFrame must have at least 2 columns with position in second column&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Ensure variant classification exists</span>
        <span class="k">if</span> <span class="s2">&quot;variant_type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variants_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variants_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Add variant classification to non-empty DataFrame</span>
                <span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">variants_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">classify_variant_type</span><span class="p">(</span>
                        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">],</span>
                        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">],</span>
                        <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span> <span class="k">if</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Handle empty DataFrame - just add empty column</span>
                <span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">variants_df</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_preprocess_bnd_derived_variants</span><span class="p">(</span><span class="n">chrom_variants</span><span class="p">,</span> <span class="n">vcf_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert BND-derived DUP/INV pairs to synthetic SV_DUP/SV_INV variants.</span>

<span class="sd">    This pre-processing step allows BND-derived structural variants to be processed</span>
<span class="sd">    by the existing SV_DUP/SV_INV logic, ensuring proper frozen region tracking</span>
<span class="sd">    and coordinate transformation.</span>

<span class="sd">    Args:</span>
<span class="sd">        chrom_variants: DataFrame of variants for a single chromosome</span>
<span class="sd">        vcf_path: Path to VCF file for BND classification (optional)</span>
<span class="sd">        verbose: Print processing information</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with BND-derived variants replaced by synthetic variants</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">parse_breakend_alt</span>

    <span class="c1"># Extract BND-derived variants that need pair processing</span>
    <span class="n">bnd_dup_variants</span> <span class="o">=</span> <span class="n">chrom_variants</span><span class="p">[</span>
        <span class="n">chrom_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SV_BND_DUP&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">bnd_inv_variants</span> <span class="o">=</span> <span class="n">chrom_variants</span><span class="p">[</span>
        <span class="n">chrom_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SV_BND_INV&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_dup_variants</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_inv_variants</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">chrom_variants</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;  üîÑ Pre-processing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bnd_dup_variants</span><span class="p">)</span><span class="si">}</span><span class="s2"> BND-DUP + </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bnd_inv_variants</span><span class="p">)</span><span class="si">}</span><span class="s2"> BND-INV variants&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Get BND classification results to find mate coordinates</span>
    <span class="n">synthetic_variants</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">processed_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Process BND-derived duplications</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">bnd_dup_variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">variant</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">processed_ids</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Parse mate coordinates from ALT field</span>
        <span class="n">alt_info</span> <span class="o">=</span> <span class="n">parse_breakend_alt</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    ‚ö†Ô∏è Could not parse BND ALT field: </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">mate_chrom</span> <span class="o">=</span> <span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;mate_chrom&quot;</span><span class="p">]</span>
        <span class="n">mate_pos</span> <span class="o">=</span> <span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">]</span>

        <span class="c1"># Ensure this is an intrachromosomal duplication (same chromosome)</span>
        <span class="k">if</span> <span class="n">mate_chrom</span> <span class="o">!=</span> <span class="n">variant</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;    ‚ö†Ô∏è Skipping interchromosomal BND: </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;chrom&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;pos1&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">mate_chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">mate_pos</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Calculate duplication region boundaries</span>
        <span class="n">start_pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">],</span> <span class="n">mate_pos</span><span class="p">)</span>
        <span class="n">end_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">],</span> <span class="n">mate_pos</span><span class="p">)</span>

        <span class="c1"># Create synthetic SV_DUP variant</span>
        <span class="n">synthetic_variant</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SV_DUP&quot;</span>
        <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_pos</span>
        <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>  <span class="c1"># Placeholder</span>
        <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&lt;DUP&gt;&quot;</span>
        <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;END=</span><span class="si">{</span><span class="n">end_pos</span><span class="si">}</span><span class="s2">;SVTYPE=DUP&quot;</span>

        <span class="n">synthetic_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synthetic_variant</span><span class="p">)</span>
        <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">region_length</span> <span class="o">=</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="n">start_pos</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;    ‚úÖ Created synthetic DUP: </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;chrom&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_pos</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">end_pos</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">region_length</span><span class="si">}</span><span class="s2">bp)&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Process BND-derived inversions: handle 4-breakend inversion topology</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_inv_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Group BND inversions by chromosome to handle 4-breakend patterns</span>
        <span class="n">chrom_groups</span> <span class="o">=</span> <span class="n">bnd_inv_variants</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;chrom&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">chrom_bnd_invs</span> <span class="ow">in</span> <span class="n">chrom_groups</span><span class="p">:</span>
            <span class="n">chrom_breakends</span> <span class="o">=</span> <span class="n">chrom_bnd_invs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Check if we have exactly 4 breakends (standard inversion pattern)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom_breakends</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># Sort breakends by position to identify topology</span>
                <span class="n">chrom_breakends</span> <span class="o">=</span> <span class="n">chrom_breakends</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;pos1&quot;</span><span class="p">)</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">chrom_breakends</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="c1"># 4-breakend inversion: outer breakpoints define boundaries, inner breakpoints define inverted region</span>
                <span class="c1"># Positions: [W, V, U, X] where W-X are outer, V-U are inner (get inverted)</span>
                <span class="n">outer_start</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># W (position 10)</span>
                <span class="n">inner_start</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># V (position 11)</span>
                <span class="n">inner_end</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># U (position 30)</span>
                <span class="n">outer_end</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># X (position 31)</span>

                <span class="c1"># Create single synthetic SV_INV for the inner region (what gets inverted)</span>
                <span class="n">first_variant</span> <span class="o">=</span> <span class="n">chrom_breakends</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">synthetic_variant</span> <span class="o">=</span> <span class="n">first_variant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SV_INV&quot;</span>
                <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inner_start</span>  <span class="c1"># Start of inverted region</span>
                <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>  <span class="c1"># Placeholder</span>
                <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&lt;INV&gt;&quot;</span>
                <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;END=</span><span class="si">{</span><span class="n">inner_end</span><span class="si">}</span><span class="s2">;SVTYPE=INV&quot;</span>  <span class="c1"># End of inverted region</span>
                <span class="p">)</span>

                <span class="n">synthetic_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synthetic_variant</span><span class="p">)</span>

                <span class="c1"># Mark all 4 breakends as processed</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">chrom_breakends</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">inversion_length</span> <span class="o">=</span> <span class="n">inner_end</span> <span class="o">-</span> <span class="n">inner_start</span>
                    <span class="n">boundary_span</span> <span class="o">=</span> <span class="n">outer_end</span> <span class="o">-</span> <span class="n">outer_start</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;    ‚úÖ Created synthetic INV: </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">inner_start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">inner_end</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">inversion_length</span><span class="si">}</span><span class="s2">bp) [4-breakend topology, boundary span </span><span class="si">{</span><span class="n">outer_start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">outer_end</span><span class="si">}</span><span class="s2">]&quot;</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Handle non-standard cases (not exactly 4 breakends)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;    ‚ö†Ô∏è Non-standard BND inversion pattern: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom_breakends</span><span class="p">)</span><span class="si">}</span><span class="s2"> breakends on </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Fallback: process individually for non-4-breakend cases</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">chrom_breakends</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">variant</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">processed_ids</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Parse mate coordinates from ALT field</span>
                    <span class="n">alt_info</span> <span class="o">=</span> <span class="n">parse_breakend_alt</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;is_valid&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;    ‚ö†Ô∏è Could not parse BND ALT field: </span><span class="si">{</span><span class="n">variant</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="n">mate_pos</span> <span class="o">=</span> <span class="n">alt_info</span><span class="p">[</span><span class="s2">&quot;mate_pos&quot;</span><span class="p">]</span>
                    <span class="n">start_pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">],</span> <span class="n">mate_pos</span><span class="p">)</span>
                    <span class="n">end_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">],</span> <span class="n">mate_pos</span><span class="p">)</span>

                    <span class="c1"># Create synthetic SV_INV variant</span>
                    <span class="n">synthetic_variant</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SV_INV&quot;</span>
                    <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_pos</span>
                    <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>
                    <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&lt;INV&gt;&quot;</span>
                    <span class="n">synthetic_variant</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;END=</span><span class="si">{</span><span class="n">end_pos</span><span class="si">}</span><span class="s2">;SVTYPE=INV&quot;</span>

                    <span class="n">synthetic_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synthetic_variant</span><span class="p">)</span>
                    <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variant</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">region_length</span> <span class="o">=</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="n">start_pos</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;    ‚úÖ Created synthetic INV: </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_pos</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">end_pos</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">region_length</span><span class="si">}</span><span class="s2">bp) [fallback]&quot;</span>
                        <span class="p">)</span>

    <span class="c1"># Create result DataFrame: remove BND-derived variants, add synthetic variants</span>
    <span class="n">result_variants</span> <span class="o">=</span> <span class="n">chrom_variants</span><span class="p">[</span>
        <span class="o">~</span><span class="n">chrom_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;SV_BND_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_BND_INV&quot;</span><span class="p">])</span>
    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">synthetic_variants</span><span class="p">:</span>
        <span class="n">synthetic_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">synthetic_variants</span><span class="p">)</span>
        <span class="n">result_variants</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">result_variants</span><span class="p">,</span> <span class="n">synthetic_df</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Re-sort by position to maintain VCF order</span>
        <span class="n">result_variants</span> <span class="o">=</span> <span class="n">result_variants</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;pos1&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">synthetic_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;  üéØ Pre-processing complete: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">synthetic_variants</span><span class="p">)</span><span class="si">}</span><span class="s2"> synthetic variants created&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">result_variants</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_format_skipped_variant_report</span><span class="p">(</span><span class="n">skipped_variants_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format skipped variant details for reporting.</span>

<span class="sd">    Args:</span>
<span class="sd">        skipped_variants_list: List of (vcf_line, chrom, pos1, ref, alt, reason) tuples</span>

<span class="sd">    Returns:</span>
<span class="sd">        Formatted string with grouped skip reasons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skipped_variants_list</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

    <span class="c1"># Group by reason</span>
    <span class="n">by_reason</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">vcf_line</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">reason</span> <span class="ow">in</span> <span class="n">skipped_variants_list</span><span class="p">:</span>
        <span class="n">by_reason</span><span class="p">[</span><span class="n">reason</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">vcf_line</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">alt</span><span class="p">))</span>

    <span class="c1"># Format output</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">reason_labels</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;overlap&quot;</span><span class="p">:</span> <span class="s2">&quot;overlap with previous variant&quot;</span><span class="p">,</span>
        <span class="s2">&quot;unsupported_type&quot;</span><span class="p">:</span> <span class="s2">&quot;unsupported variant type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;validation_error&quot;</span><span class="p">:</span> <span class="s2">&quot;validation error&quot;</span><span class="p">,</span>
        <span class="s2">&quot;missing_type&quot;</span><span class="p">:</span> <span class="s2">&quot;missing/unknown type&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">reason</span><span class="p">,</span> <span class="n">variants</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">by_reason</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">reason_labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reason</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
        <span class="c1"># Group by position for concise output</span>
        <span class="n">by_pos</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vcf_line</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">alt</span> <span class="ow">in</span> <span class="n">variants</span><span class="p">:</span>
            <span class="n">by_pos</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">pos1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vcf_line</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">vcf_lines</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">by_pos</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">vcf_lines_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vcf_lines</span><span class="p">)))</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     ‚Ä¢ </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">: VCF line(s) </span><span class="si">{</span><span class="n">vcf_lines_str</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<div class="viewcode-block" id="get_personal_genome">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.get_personal_genome">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_personal_genome</span><span class="p">(</span>
    <span class="n">reference_fn</span><span class="p">,</span>
    <span class="n">variants_fn</span><span class="p">,</span>
    <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">n_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a personalized genome by applying variants to a reference genome.</span>

<span class="sd">    This function implements multi-phase variant processing with proper frozen region tracking:</span>

<span class="sd">    Phase 1: Standard variants + Early structural variants (in VCF order):</span>
<span class="sd">        - SNV, MNV, INS, DEL, SV_DUP, SV_INV</span>

<span class="sd">    Phase 2: BND semantic classification and application:</span>
<span class="sd">        - Classify BNDs to identify SV_BND_DUP and SV_BND_INV patterns</span>
<span class="sd">        - Apply SV_BND_DUP and SV_BND_INV first</span>
<span class="sd">        - Apply remaining true BND translocations</span>

<span class="sd">    Frozen region enforcement:</span>
<span class="sd">        - Each variant freezes its genomic region after application</span>
<span class="sd">        - Later variants overlapping frozen regions are skipped with warnings</span>
<span class="sd">        - BND breakpoints in frozen regions cause entire BND to be skipped</span>

<span class="sd">    Output chromosome ordering:</span>
<span class="sd">        - Chromosomes are returned in the same order as the reference genome</span>
<span class="sd">        - BND-generated fusion sequences appear after all original chromosomes</span>
<span class="sd">        - Leftover sequences (from consumed chromosomes) follow fusion sequences</span>

<span class="sd">    Args:</span>
<span class="sd">        reference_fn: Path to reference genome file or dictionary-like object</span>
<span class="sd">        variants_fn: Path to variants file or DataFrame. Supports VCF 4.2 format</span>
<span class="sd">                    including BND (breakend) variants with bracket notation.</span>
<span class="sd">        encode: Return sequences as one-hot encoded arrays (default: True)</span>
<span class="sd">        n_chunks: Number of chunks to split variants into for processing (default: 1)</span>
<span class="sd">        verbose: Print progress information (default: False)</span>
<span class="sd">        encoder: Optional custom encoding function. If provided, should accept a single</span>
<span class="sd">                sequence string and return encoded array with shape (L, 4). Default: None</span>
<span class="sd">        auto_map_chromosomes: Automatically map chromosome names between VCF and reference</span>
<span class="sd">                             when they don&#39;t match exactly (e.g., &#39;chr1&#39; &lt;-&gt; &#39;1&#39;, &#39;chrM&#39; &lt;-&gt; &#39;MT&#39;).</span>
<span class="sd">                             Default: False. When False, raises ChromosomeMismatchError if names</span>
<span class="sd">                             don&#39;t match. (default: False)</span>

<span class="sd">    Returns:</span>
<span class="sd">        If encode=True: A dictionary mapping chromosome names to encoded tensors/arrays</span>
<span class="sd">        If encode=False: A dictionary mapping chromosome names to sequence strings</span>

<span class="sd">        The dictionary preserves reference genome chromosome order, with any fusion</span>
<span class="sd">        or leftover sequences appended at the end.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ChromosomeMismatchError: If auto_map_chromosomes=False and chromosome names in VCF</span>
<span class="sd">                                and reference don&#39;t match exactly</span>

<span class="sd">    Examples:</span>
<span class="sd">        # Apply variants with proper ordering and conflict resolution</span>
<span class="sd">        personal_genome = get_personal_genome(&#39;reference.fa&#39;, &#39;variants.vcf&#39;)</span>

<span class="sd">        # Get raw sequences without encoding</span>
<span class="sd">        personal_genome = get_personal_genome(&#39;reference.fa&#39;, &#39;variants.vcf&#39;, encode=False)</span>

<span class="sd">        # Enable automatic chromosome mapping if VCF uses &#39;chr1&#39; and reference uses &#39;1&#39;</span>
<span class="sd">        personal_genome = get_personal_genome(&#39;reference.fa&#39;, &#39;variants.vcf&#39;, auto_map_chromosomes=True)</span>

<span class="sd">        # Verify chromosome order is preserved</span>
<span class="sd">        ref_chroms = list(pyfaidx.Fasta(&#39;reference.fa&#39;).keys())</span>
<span class="sd">        personal_chroms = list(personal_genome.keys())</span>
<span class="sd">        assert personal_chroms[:len(ref_chroms)] == ref_chroms  # Original order preserved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load ALL variants with classification</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">group_variants_by_semantic_type</span>

    <span class="n">variants_df</span> <span class="o">=</span> <span class="n">_load_variants</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">)</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">_load_reference</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variants_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;üß¨ No variants found - returning reference genome&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_encode_genome_sequences</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">encode</span><span class="p">,</span> <span class="n">encoder</span><span class="p">)</span>

    <span class="c1"># Group variants by semantic type for proper processing order</span>
    <span class="c1"># Pass VCF path for BND semantic classification if available</span>
    <span class="n">vcf_path</span> <span class="o">=</span> <span class="n">variants_fn</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">grouped_variants</span> <span class="o">=</span> <span class="n">group_variants_by_semantic_type</span><span class="p">(</span><span class="n">variants_df</span><span class="p">,</span> <span class="n">vcf_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">total_variants</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variants_df</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;üß¨ Processing </span><span class="si">{</span><span class="n">total_variants</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> variants across </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">variants_df</span><span class="p">[</span><span class="s1">&#39;chrom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2"> chromosomes&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;   Phase 1: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s1">&#39;standard&#39;</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s1">&#39;dup_variants&#39;</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s1">&#39;inv_variants&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> standard variants (SNV, MNV, INS, DEL, SV_DUP, SV_INV)&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;   Phase 2: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s1">&#39;bnd_variants&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> BND variants for semantic classification&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Apply chromosome name matching</span>
    <span class="n">ref_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">vcf_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variants_df</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

    <span class="n">mapping</span><span class="p">,</span> <span class="n">unmatched</span> <span class="o">=</span> <span class="n">match_chromosomes_with_report</span><span class="p">(</span>
        <span class="n">ref_chroms</span><span class="p">,</span>
        <span class="n">vcf_chroms</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="n">auto_map_chromosomes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Apply chromosome name mapping to all variants</span>
    <span class="k">if</span> <span class="n">mapping</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">variant_group</span> <span class="ow">in</span> <span class="n">grouped_variants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">grouped_variants</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">apply_chromosome_mapping</span><span class="p">(</span>
                    <span class="n">variant_group</span><span class="p">,</span> <span class="n">mapping</span>
                <span class="p">)</span>

    <span class="c1"># Initialize processing state</span>
    <span class="n">personal_genome</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">total_processed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">offset_tracker</span> <span class="o">=</span> <span class="n">ChromosomeOffsetTracker</span><span class="p">()</span>
    <span class="n">modified_sequences</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># PHASE 1: Apply standard variants + early structural variants (in VCF order)</span>
    <span class="c1"># Include both symbolic and BND-derived DUP/INV variants</span>
    <span class="n">symbolic_dup_variants</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">][</span>
            <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">][</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SV_DUP&quot;</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">symbolic_inv_variants</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">][</span>
            <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">][</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SV_INV&quot;</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Extract BND-derived DUP/INV variants for Phase 1 processing</span>
    <span class="n">bnd_dup_variants</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">][</span>
            <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">][</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SV_BND_DUP&quot;</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;dup_variants&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">bnd_inv_variants</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">][</span>
            <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">][</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SV_BND_INV&quot;</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;inv_variants&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">phase1_variants</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;standard&quot;</span><span class="p">],</span>
            <span class="n">symbolic_dup_variants</span><span class="p">,</span>
            <span class="n">symbolic_inv_variants</span><span class="p">,</span>
            <span class="n">bnd_dup_variants</span><span class="p">,</span>
            <span class="n">bnd_inv_variants</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase1_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Sort by chromosome and position to maintain VCF order</span>
        <span class="n">phase1_variants</span> <span class="o">=</span> <span class="n">phase1_variants</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;chrom&quot;</span><span class="p">,</span> <span class="s2">&quot;pos1&quot;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">chrom_variants</span> <span class="ow">in</span> <span class="n">phase1_variants</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;chrom&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;‚ö†Ô∏è  Skipping </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">: not found in reference&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">ref_seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">chrom</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">variant_counts</span> <span class="o">=</span> <span class="n">chrom_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                <span class="n">type_summary</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vtype</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">vtype</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">variant_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;üîÑ Processing chromosome </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom_variants</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> variants (</span><span class="si">{</span><span class="n">type_summary</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Process all Phase 1 variants with offset tracking (chunking available for standard variants only)</span>
            <span class="k">if</span> <span class="n">n_chunks</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">vtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SV_DUP&quot;</span><span class="p">,</span> <span class="s2">&quot;SV_INV&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">vtype</span> <span class="ow">in</span> <span class="n">chrom_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="c1"># PRE-PROCESS: Convert BND-derived variants to synthetic variants</span>
                <span class="n">processed_variants</span> <span class="o">=</span> <span class="n">_preprocess_bnd_derived_variants</span><span class="p">(</span>
                    <span class="n">chrom_variants</span><span class="p">,</span> <span class="n">vcf_path</span><span class="p">,</span> <span class="n">verbose</span>
                <span class="p">)</span>

                <span class="c1"># Process all variants at once (required for structural variants)</span>
                <span class="n">applicator</span> <span class="o">=</span> <span class="n">VariantApplicator</span><span class="p">(</span>
                    <span class="n">ref_seq</span><span class="p">,</span>
                    <span class="n">processed_variants</span><span class="p">,</span>
                    <span class="n">offset_tracker</span><span class="o">=</span><span class="n">offset_tracker</span><span class="p">,</span>
                    <span class="n">chrom</span><span class="o">=</span><span class="n">chrom</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">personal_seq</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">applicator</span><span class="o">.</span><span class="n">apply_variants</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Report skipped variants if any</span>
                    <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;skipped&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;skipped_variants&quot;</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ‚ö†Ô∏è  Skipped </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;skipped&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> variant(s):&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">_format_skipped_variant_report</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;skipped_variants&quot;</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;  ‚úÖ Applied </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;applied&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> variants (</span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;skipped&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> skipped)&quot;</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># PRE-PROCESS: Convert BND-derived variants to synthetic variants (for chunked processing too)</span>
                <span class="n">processed_variants</span> <span class="o">=</span> <span class="n">_preprocess_bnd_derived_variants</span><span class="p">(</span>
                    <span class="n">chrom_variants</span><span class="p">,</span> <span class="n">vcf_path</span><span class="p">,</span> <span class="n">verbose</span>
                <span class="p">)</span>

                <span class="c1"># Process in chunks (standard variants only)</span>
                <span class="n">current_sequence</span> <span class="o">=</span> <span class="n">ref_seq</span>
                <span class="n">shared_frozen_tracker</span> <span class="o">=</span> <span class="n">FrozenRegionTracker</span><span class="p">()</span>
                <span class="n">total_applied</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">total_skipped</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">all_skipped_variants</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">processed_variants</span><span class="p">)),</span> <span class="n">n_chunks</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">avg_chunk_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed_variants</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_chunks</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;  üì¶ Processing </span><span class="si">{</span><span class="n">n_chunks</span><span class="si">}</span><span class="s2"> chunks of ~</span><span class="si">{</span><span class="n">avg_chunk_size</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> variants each&quot;</span>
                    <span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">chunk_df</span> <span class="o">=</span> <span class="n">processed_variants</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">chunk_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
                        <span class="n">drop</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                    <span class="n">applicator</span> <span class="o">=</span> <span class="n">VariantApplicator</span><span class="p">(</span>
                        <span class="n">current_sequence</span><span class="p">,</span>
                        <span class="n">chunk_df</span><span class="p">,</span>
                        <span class="n">shared_frozen_tracker</span><span class="p">,</span>
                        <span class="n">offset_tracker</span><span class="p">,</span>
                        <span class="n">chrom</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">current_sequence</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">applicator</span><span class="o">.</span><span class="n">apply_variants</span><span class="p">()</span>

                    <span class="n">total_applied</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;applied&quot;</span><span class="p">]</span>
                    <span class="n">total_skipped</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;skipped&quot;</span><span class="p">]</span>
                    <span class="n">all_skipped_variants</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;skipped_variants&quot;</span><span class="p">,</span> <span class="p">[]))</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;    ‚úÖ Chunk </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;applied&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> variants applied&quot;</span>
                        <span class="p">)</span>

                <span class="n">personal_seq</span> <span class="o">=</span> <span class="n">current_sequence</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="c1"># Report skipped variants if any</span>
                    <span class="k">if</span> <span class="n">total_skipped</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">all_skipped_variants</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ‚ö†Ô∏è  Skipped </span><span class="si">{</span><span class="n">total_skipped</span><span class="si">}</span><span class="s2"> variant(s):&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">_format_skipped_variant_report</span><span class="p">(</span><span class="n">all_skipped_variants</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;  üéØ Total: </span><span class="si">{</span><span class="n">total_applied</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">processed_variants</span><span class="p">)</span><span class="si">}</span><span class="s2"> variants applied (</span><span class="si">{</span><span class="n">total_skipped</span><span class="si">}</span><span class="s2"> skipped)&quot;</span>
                    <span class="p">)</span>

            <span class="n">modified_sequences</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">personal_seq</span>
            <span class="n">total_processed</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom_variants</span><span class="p">)</span>

    <span class="c1"># Initialize sequences for chromosomes not processed in Phase 1</span>
    <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">reference</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modified_sequences</span><span class="p">:</span>
            <span class="n">modified_sequences</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">chrom</span><span class="p">])</span>

    <span class="c1"># PHASE 2: BND translocation processing</span>
    <span class="c1"># Only process true BND translocations (BND-derived DUP/INV are now handled in Phase 1)</span>
    <span class="n">true_bnd_variants</span> <span class="o">=</span> <span class="n">grouped_variants</span><span class="p">[</span><span class="s2">&quot;bnd_variants&quot;</span><span class="p">]</span>

    <span class="c1"># Phase 2 variants are now only true BND translocations</span>
    <span class="n">phase2_variants</span> <span class="o">=</span> <span class="n">true_bnd_variants</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase2_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">phase2_counts</span> <span class="o">=</span> <span class="n">phase2_variants</span><span class="p">[</span><span class="s2">&quot;variant_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">counts_msg</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vtype</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">vtype</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">phase2_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;üîÑ Phase 2: Processing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">phase2_variants</span><span class="p">)</span><span class="si">}</span><span class="s2"> BND variants with semantic classification (</span><span class="si">{</span><span class="n">counts_msg</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Use the BND classifier results directly instead of create_breakend_pairs</span>
        <span class="c1"># This ensures we get the inferred mates that the classifier created</span>
        <span class="k">if</span> <span class="n">vcf_path</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">BNDClassifier</span>

            <span class="n">classifier</span> <span class="o">=</span> <span class="n">BNDClassifier</span><span class="p">()</span>
            <span class="n">classified_breakends</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">classify_all_breakends</span><span class="p">(</span>
                <span class="n">vcf_path</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
            <span class="p">)</span>

            <span class="c1"># Extract all paired breakends (including those with inferred mates)</span>
            <span class="n">all_paired_breakends</span> <span class="o">=</span> <span class="n">classified_breakends</span><span class="p">[</span><span class="s2">&quot;paired&quot;</span><span class="p">]</span>

            <span class="c1"># Convert to BreakendPair-like objects for ChimericSequenceBuilder compatibility</span>
            <span class="n">breakend_pairs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">processed_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">breakend</span> <span class="ow">in</span> <span class="n">all_paired_breakends</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">breakend</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">processed_ids</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Create a pair tuple (bnd1, bnd2) for ChimericSequenceBuilder</span>
                <span class="n">pair_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">breakend</span><span class="p">,</span> <span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span><span class="p">)</span>
                <span class="n">breakend_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair_tuple</span><span class="p">)</span>
                <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">processed_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">breakend</span><span class="o">.</span><span class="n">mate_breakend</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback to create_breakend_pairs if no VCF path available</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_breakend_pairs</span>

            <span class="n">breakend_pairs</span> <span class="o">=</span> <span class="n">create_breakend_pairs</span><span class="p">(</span><span class="n">phase2_variants</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">breakend_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">breakend_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2"> BND pairs for processing&quot;</span><span class="p">)</span>

            <span class="c1"># Transform BND coordinates using offset tracker from Phase 1</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
                <span class="c1"># Handle both BreakendPair objects and tuple pairs</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="s2">&quot;breakend1&quot;</span><span class="p">):</span>
                    <span class="n">bnd1</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend1</span>
                    <span class="n">bnd2</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="o">=</span> <span class="n">pair</span>

                <span class="n">original_pos1</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span>
                <span class="n">original_pos2</span> <span class="o">=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span>

                <span class="c1"># Transform coordinates to account for applied Phase 1 variants</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">offset_tracker</span><span class="p">,</span> <span class="s2">&quot;get_offset_at_position&quot;</span><span class="p">):</span>
                    <span class="n">bnd1_offset</span> <span class="o">=</span> <span class="n">offset_tracker</span><span class="o">.</span><span class="n">get_offset_at_position</span><span class="p">(</span>
                        <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="n">bnd2_offset</span> <span class="o">=</span> <span class="n">offset_tracker</span><span class="o">.</span><span class="n">get_offset_at_position</span><span class="p">(</span>
                        <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">bnd1_offset</span>
                    <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">bnd2_offset</span>

                    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bnd1_offset</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bnd2_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;   üìç Transformed coordinates: </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">original_pos1</span><span class="si">}</span><span class="s2">‚Üí</span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">original_pos2</span><span class="si">}</span><span class="s2">‚Üí</span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

            <span class="c1"># Note: BND semantic classification (SV_BND_DUP, SV_BND_INV) is handled by</span>
            <span class="c1"># group_variants_by_semantic_type() and _preprocess_bnd_derived_variants().</span>
            <span class="c1"># Remaining BND variants are processed as translocations using ChimericSequenceBuilder.</span>

            <span class="c1"># Enhanced frozen region validation for BND breakpoints</span>
            <span class="n">validated_pairs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">skipped_pairs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
                <span class="c1"># Handle both BreakendPair objects and tuple pairs</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="s2">&quot;breakend1&quot;</span><span class="p">):</span>
                    <span class="n">bnd1</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend1</span>
                    <span class="n">bnd2</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="o">=</span> <span class="n">pair</span>

                <span class="c1"># Check if both breakpoints are in non-frozen regions</span>
                <span class="c1"># Create a temporary FrozenRegionTracker to check current frozen regions</span>
                <span class="c1"># Note: This is a simplified check - a more sophisticated implementation would</span>
                <span class="c1"># track frozen regions across all chromosomes from Phase 1</span>

                <span class="n">breakpoint_conflicts</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Note: Frozen region tracking is handled by FrozenRegionTracker within each chromosome</span>
                <span class="c1"># processing. Cross-Phase conflict detection could be enhanced in future versions.</span>
                <span class="k">if</span> <span class="n">breakpoint_conflicts</span><span class="p">:</span>
                    <span class="n">skipped_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">conflicts_msg</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">breakpoint_conflicts</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;   ‚ö†Ô∏è Skipping BND pair </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">conflicts_msg</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">validated_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;   üìç Skipped </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">skipped_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2"> BND pairs due to frozen region conflicts&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Create chimeric sequences using validated pairs only</span>
            <span class="n">sequence_builder</span> <span class="o">=</span> <span class="n">ChimericSequenceBuilder</span><span class="p">(</span><span class="n">modified_sequences</span><span class="p">)</span>

            <span class="c1"># Initialize segment tracker with original reference chromosomes only</span>
            <span class="n">original_ref_sequences</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">chrom</span><span class="p">:</span> <span class="n">seq</span>
                <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">modified_sequences</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;_fusion_&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chrom</span>
            <span class="p">}</span>
            <span class="n">segment_tracker</span> <span class="o">=</span> <span class="n">ChromosomeSegmentTracker</span><span class="p">(</span><span class="n">original_ref_sequences</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">validated_pairs</span><span class="p">):</span>
                <span class="c1"># Handle both BreakendPair objects and tuple pairs for display</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="s2">&quot;breakend1&quot;</span><span class="p">):</span>
                    <span class="n">bnd1_id</span><span class="p">,</span> <span class="n">bnd2_id</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend2</span><span class="o">.</span><span class="n">id</span>
                    <span class="n">pair_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">breakend1</span><span class="p">,</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend2</span><span class="p">)</span>
                    <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend1</span><span class="p">,</span> <span class="n">pair</span><span class="o">.</span><span class="n">breakend2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bnd1_id</span><span class="p">,</span> <span class="n">bnd2_id</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
                    <span class="n">pair_tuple</span> <span class="o">=</span> <span class="n">pair</span>
                    <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;   üîÑ Creating fusion </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">validated_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">bnd1_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">bnd2_id</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fusion_name</span><span class="p">,</span> <span class="n">fusion_seq</span> <span class="o">=</span> <span class="n">sequence_builder</span><span class="o">.</span><span class="n">create_fusion_from_pair</span><span class="p">(</span>
                        <span class="n">pair_tuple</span>
                    <span class="p">)</span>
                    <span class="n">modified_sequences</span><span class="p">[</span><span class="n">fusion_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fusion_seq</span>
                    <span class="n">total_processed</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Count both BNDs in the pair</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;     ‚úÖ Created fusion: </span><span class="si">{</span><span class="n">fusion_name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fusion_seq</span><span class="p">)</span><span class="si">}</span><span class="s2"> bp)&quot;</span>
                        <span class="p">)</span>

                    <span class="c1"># Track chromosome segment usage based on fusion orientations</span>
                    <span class="n">pos1_0</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>
                    <span class="n">pos2_0</span> <span class="o">=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>
                    <span class="n">seq1_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modified_sequences</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">])</span>
                    <span class="n">seq2_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modified_sequences</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">])</span>

                    <span class="c1"># Track segments used based on the actual fusion logic from prototype</span>
                    <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;t]p]&quot;</span> <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;t]p]&quot;</span><span class="p">:</span>
                        <span class="c1"># seq1[:pos1] + RC(seq2[:pos2]) - uses chromosome prefixes</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>  <span class="c1"># VCF pos as count</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>  <span class="c1"># VCF pos as count</span>
                    <span class="k">elif</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span> <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span><span class="p">:</span>
                        <span class="c1"># seq2[:pos2] + seq1[pos1_0:] - prefix from seq2, suffix from seq1</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>  <span class="c1"># VCF pos as count</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos1_0</span><span class="p">,</span> <span class="n">seq1_len</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;[p[t&quot;</span> <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;[p[t&quot;</span><span class="p">:</span>
                        <span class="c1"># RC(seq2[pos2_0:]) + seq1[pos1_0:] - uses chromosome suffixes</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos2_0</span><span class="p">,</span> <span class="n">seq2_len</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos1_0</span><span class="p">,</span> <span class="n">seq1_len</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span> <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span><span class="p">:</span>
                        <span class="c1"># seq1[:pos1_0] + seq2[pos2_0:] - prefix from seq1, suffix from seq2</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos1_0</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos2_0</span><span class="p">,</span> <span class="n">seq2_len</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;t[p[&quot;</span> <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span><span class="p">:</span>
                        <span class="c1"># seq1[:pos1_0] + seq2[pos2_0:] - prefix from seq1, suffix from seq2</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos1_0</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos2_0</span><span class="p">,</span> <span class="n">seq2_len</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span> <span class="ow">and</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;]p]t&quot;</span><span class="p">:</span>
                        <span class="c1"># seq2[:pos2] + seq1[pos1_0:] - prefix from seq2, suffix from seq1</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>  <span class="c1"># VCF pos as count</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos1_0</span><span class="p">,</span> <span class="n">seq1_len</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Unknown orientation patterns - track conservatively</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;     ‚ö†Ô∏è Unknown orientation pattern: </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos1_0</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
                        <span class="n">segment_tracker</span><span class="o">.</span><span class="n">add_used_segment</span><span class="p">(</span>
                            <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos2_0</span><span class="p">,</span> <span class="n">seq2_len</span><span class="p">,</span> <span class="n">verbose</span>
                        <span class="p">)</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;     ‚ö†Ô∏è Failed to create fusion for </span><span class="si">{</span><span class="n">bnd1_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">bnd2_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

            <span class="c1"># Calculate and add leftover sequences</span>
            <span class="n">leftover_sequences</span> <span class="o">=</span> <span class="n">segment_tracker</span><span class="o">.</span><span class="n">get_leftover_sequences</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

            <span class="c1"># Remove original chromosomes that were consumed by fusions and replace with leftovers</span>
            <span class="n">chromosomes_with_fusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">seq_name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">modified_sequences</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="s2">&quot;_fusion_&quot;</span> <span class="ow">in</span> <span class="n">seq_name</span><span class="p">:</span>
                    <span class="c1"># Extract chromosome names from fusion sequence names</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">seq_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">chromosomes_with_fusions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">chromosomes_with_fusions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Remove consumed chromosomes and add their leftovers</span>
            <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">chromosomes_with_fusions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">modified_sequences</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">modified_sequences</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   üóëÔ∏è Removed consumed chromosome: </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Add leftover sequences</span>
            <span class="n">modified_sequences</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">leftover_sequences</span><span class="p">)</span>

    <span class="c1"># FINAL STEP: Encode sequences and create output</span>
    <span class="c1"># Preserve reference chromosome order, then append fusion/leftover sequences</span>
    <span class="n">reference_chroms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># First, add chromosomes in reference order</span>
    <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">reference_chroms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">modified_sequences</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">modified_sequences</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">encode</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">encoder</span><span class="p">:</span>
                    <span class="n">personal_genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">personal_genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">encode_seq</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">personal_genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span>

    <span class="c1"># Then, add fusion and leftover sequences (not in original reference)</span>
    <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">modified_sequences</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference_chroms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">encode</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">encoder</span><span class="p">:</span>
                    <span class="n">personal_genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">personal_genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">encode_seq</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">personal_genome</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">total_variants</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variants_df</span><span class="p">)</span>
        <span class="n">sequences_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">personal_genome</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> sequences&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;_fusion_&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">personal_genome</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">fusion_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="mi">1</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">personal_genome</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;_fusion_&quot;</span> <span class="ow">in</span> <span class="n">name</span>
            <span class="p">)</span>
            <span class="n">leftover_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">personal_genome</span><span class="p">)</span> <span class="o">-</span> <span class="n">fusion_count</span>
            <span class="n">sequences_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fusion_count</span><span class="si">}</span><span class="s2"> fusions, </span><span class="si">{</span><span class="n">leftover_count</span><span class="si">}</span><span class="s2"> leftover sequences&quot;</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;üß¨ Completed: </span><span class="si">{</span><span class="n">total_processed</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">total_variants</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> variants processed ‚Üí </span><span class="si">{</span><span class="n">sequences_msg</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">personal_genome</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_generate_sequence_metadata</span><span class="p">(</span><span class="n">chunk_variants</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate standardized metadata for sequence functions.</span>

<span class="sd">    This centralizes metadata generation to eliminate duplication across</span>
<span class="sd">    get_alt_sequences, get_ref_sequences, and get_alt_ref_sequences.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_variants: DataFrame of variants for this chunk</span>
<span class="sd">        seq_len: Length of the sequence window</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: Comprehensive metadata with standardized columns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">chunk_variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1"># Basic position calculations</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span>  <span class="c1"># 1-based VCF position</span>
        <span class="n">genomic_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>
        <span class="n">half_len</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">window_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">half_len</span><span class="p">)</span>
        <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_len</span>

        <span class="c1"># Variant classification</span>
        <span class="n">variant_type</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variant_type&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">)</span>

        <span class="c1"># Build minimal metadata dictionary</span>
        <span class="n">meta_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;chrom&quot;</span><span class="p">:</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">],</span>
            <span class="s2">&quot;window_start&quot;</span><span class="p">:</span> <span class="n">window_start</span><span class="p">,</span>
            <span class="s2">&quot;window_end&quot;</span><span class="p">:</span> <span class="n">window_end</span><span class="p">,</span>
            <span class="s2">&quot;variant_pos0&quot;</span><span class="p">:</span> <span class="n">genomic_pos</span><span class="p">,</span>  <span class="c1"># 0-based absolute position</span>
            <span class="s2">&quot;variant_pos1&quot;</span><span class="p">:</span> <span class="n">pos</span><span class="p">,</span>  <span class="c1"># 1-based absolute position</span>
            <span class="s2">&quot;ref&quot;</span><span class="p">:</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">],</span>
            <span class="s2">&quot;alt&quot;</span><span class="p">:</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">],</span>
            <span class="s2">&quot;variant_type&quot;</span><span class="p">:</span> <span class="n">variant_type</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Add sym_variant_end ONLY for symbolic alleles (&lt;INV&gt;, &lt;DUP&gt;, etc.)</span>
        <span class="k">if</span> <span class="n">variant_type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;SV_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;alt&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="n">var</span> <span class="ow">and</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                <span class="n">parsed_info</span> <span class="o">=</span> <span class="n">parse_vcf_info</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">])</span>
                <span class="n">sym_end</span> <span class="o">=</span> <span class="n">parsed_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sym_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">meta_dict</span><span class="p">[</span><span class="s2">&quot;sym_variant_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym_end</span>

        <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meta_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_generate_bnd_ref_sequences</span><span class="p">(</span>
    <span class="n">breakend_pairs</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate dual reference sequences for BND variants (no ALT sequences).</span>

<span class="sd">    Args:</span>
<span class="sd">        breakend_pairs: List of breakend pairs from load_breakend_variants</span>
<span class="sd">        reference: Reference genome dictionary</span>
<span class="sd">        seq_len: Length of sequence window</span>
<span class="sd">        encode: Whether to encode sequences</span>
<span class="sd">        encoder: Optional custom encoder</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (left_ref_sequences, right_ref_sequences, metadata)</span>
<span class="sd">        left_ref_sequences contains left breakend reference (+ N-padding)</span>
<span class="sd">        right_ref_sequences contains right breakend reference (N-padding +)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.sequence_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">encode_seq</span><span class="p">,</span> <span class="n">rc_str</span>

    <span class="n">left_ref_sequences</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">right_ref_sequences</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">left_ref_sequences</span><span class="p">,</span> <span class="n">right_ref_sequences</span><span class="p">,</span> <span class="n">metadata</span>

    <span class="c1"># Process each breakend pair</span>
    <span class="k">for</span> <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get chromosome sequences</span>
            <span class="n">seq1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">])</span> <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">reference</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">seq2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">])</span> <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">reference</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">seq1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">seq2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Calculate window centered on first breakend</span>
            <span class="n">center_pos</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>

            <span class="c1"># Detect if this is a BND with insertion for consistent handling</span>
            <span class="n">has_insertion</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">inserted_seq</span> <span class="ow">or</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">)</span>
            <span class="n">insertion_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd2</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">)</span>

            <span class="c1"># Generate left reference sequence (sequence before breakend + right-side N-padding)</span>
            <span class="c1"># For BNDs, we want to show what was there BEFORE the fusion point</span>
            <span class="c1"># Then pad the right side with N&#39;s to represent the missing fusion partner + insertion</span>
            <span class="n">half_len</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="c1"># Extract sequence leading up to the breakend (before the fusion point)</span>
            <span class="n">left_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_pos</span> <span class="o">-</span> <span class="n">half_len</span><span class="p">)</span>
            <span class="n">left_end</span> <span class="o">=</span> <span class="n">center_pos</span>  <span class="c1"># Stop at the breakend position</span>
            <span class="n">left_ref_raw</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[</span><span class="n">left_start</span><span class="p">:</span><span class="n">left_end</span><span class="p">]</span>

            <span class="c1"># Pad the right side to represent where the fusion partner + insertion would attach</span>
            <span class="n">left_padding_needed</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_ref_raw</span><span class="p">)</span>
            <span class="c1"># Note: For BND with insertion, this padding represents both the missing chromosome and the insertion</span>
            <span class="n">left_ref_seq</span> <span class="o">=</span> <span class="n">left_ref_raw</span> <span class="o">+</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">left_padding_needed</span>

            <span class="c1"># Generate right reference sequence (left-side N-padding + sequence after breakend)</span>
            <span class="c1"># For the right side, we want to show what was there AFTER the fusion point</span>
            <span class="c1"># Pad the left side with N&#39;s to represent the missing fusion partner + insertion</span>
            <span class="n">bnd2_center</span> <span class="o">=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>

            <span class="c1"># Extract sequence starting from the breakend (after the fusion point)</span>
            <span class="n">right_start</span> <span class="o">=</span> <span class="n">bnd2_center</span>  <span class="c1"># Start at the breakend position</span>
            <span class="n">right_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq2</span><span class="p">),</span> <span class="n">bnd2_center</span> <span class="o">+</span> <span class="n">half_len</span><span class="p">)</span>
            <span class="n">right_ref_raw</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">right_start</span><span class="p">:</span><span class="n">right_end</span><span class="p">]</span>

            <span class="c1"># Pad the left side to represent where the fusion partner + insertion would attach</span>
            <span class="n">right_padding_needed</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_ref_raw</span><span class="p">)</span>
            <span class="c1"># Note: For BND with insertion, this padding represents both the missing chromosome and the insertion</span>
            <span class="n">right_ref_seq</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">right_padding_needed</span> <span class="o">+</span> <span class="n">right_ref_raw</span>

            <span class="c1"># Apply reverse complement if needed based on orientation</span>
            <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;t]p]&quot;</span><span class="p">,</span> <span class="s2">&quot;[p[t&quot;</span><span class="p">]:</span>  <span class="c1"># orientations requiring RC</span>
                <span class="n">left_ref_seq</span> <span class="o">=</span> <span class="n">rc_str</span><span class="p">(</span><span class="n">left_ref_seq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;t]p]&quot;</span><span class="p">,</span> <span class="s2">&quot;[p[t&quot;</span><span class="p">]:</span>
                <span class="n">right_ref_seq</span> <span class="o">=</span> <span class="n">rc_str</span><span class="p">(</span><span class="n">right_ref_seq</span><span class="p">)</span>

            <span class="c1"># Ensure sequences are exactly seq_len</span>
            <span class="n">left_ref_seq</span> <span class="o">=</span> <span class="n">left_ref_seq</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span>
            <span class="n">right_ref_seq</span> <span class="o">=</span> <span class="n">right_ref_seq</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span>

            <span class="n">left_ref_sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_ref_seq</span><span class="p">)</span>
            <span class="n">right_ref_sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_ref_seq</span><span class="p">)</span>

            <span class="c1"># Create metadata for this BND</span>
            <span class="n">window_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_pos</span> <span class="o">-</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_len</span>
            <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;chrom&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                    <span class="s2">&quot;window_start&quot;</span><span class="p">:</span> <span class="n">window_start</span><span class="p">,</span>
                    <span class="s2">&quot;window_end&quot;</span><span class="p">:</span> <span class="n">window_end</span><span class="p">,</span>
                    <span class="s2">&quot;variant_pos0&quot;</span><span class="p">:</span> <span class="n">center_pos</span><span class="p">,</span>
                    <span class="s2">&quot;variant_pos1&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                    <span class="s2">&quot;ref&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                    <span class="s2">&quot;alt&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                    <span class="s2">&quot;variant_type&quot;</span><span class="p">:</span> <span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;mate_chrom&quot;</span><span class="p">:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                    <span class="s2">&quot;mate_pos&quot;</span><span class="p">:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                    <span class="s2">&quot;orientation_1&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
                    <span class="s2">&quot;orientation_2&quot;</span><span class="p">:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Log error but continue processing other BNDs</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to process BND pair </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

    <span class="c1"># Encode sequences if requested</span>
    <span class="k">if</span> <span class="n">encode</span> <span class="ow">and</span> <span class="n">left_ref_sequences</span><span class="p">:</span>
        <span class="c1"># Encode each sequence individually and collect them</span>
        <span class="n">encoded_left_ref</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">encoded_right_ref</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_ref_sequences</span><span class="p">)):</span>
            <span class="n">encoded_left_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encode_seq</span><span class="p">(</span><span class="n">left_ref_sequences</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">encoder</span><span class="p">))</span>
            <span class="n">encoded_right_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encode_seq</span><span class="p">(</span><span class="n">right_ref_sequences</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">encoder</span><span class="p">))</span>

        <span class="c1"># Stack the encoded sequences</span>
        <span class="k">if</span> <span class="n">TORCH_AVAILABLE</span><span class="p">:</span>
            <span class="n">left_ref_sequences</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_left_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_left_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>
            <span class="n">right_ref_sequences</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_right_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_right_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_ref_sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_left_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_left_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">right_ref_sequences</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_right_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_right_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">left_ref_sequences</span><span class="p">,</span> <span class="n">right_ref_sequences</span><span class="p">,</span> <span class="n">metadata</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_generate_bnd_sequences</span><span class="p">(</span>
    <span class="n">breakend_pairs</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate ALT and reference sequences for BND variants.</span>

<span class="sd">    Args:</span>
<span class="sd">        breakend_pairs: List of breakend pairs from load_breakend_variants</span>
<span class="sd">        reference: Reference genome dictionary</span>
<span class="sd">        seq_len: Length of sequence window</span>
<span class="sd">        encode: Whether to encode sequences</span>
<span class="sd">        encoder: Optional custom encoder</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (alt_sequences, left_ref_sequences, right_ref_sequences, metadata)</span>
<span class="sd">        For BNDs: alt_sequences contains fusion sequences</span>
<span class="sd">                 left_ref_sequences contains left breakend reference (+ N-padding)</span>
<span class="sd">                 right_ref_sequences contains right breakend reference (N-padding +)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.sequence_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">encode_seq</span><span class="p">,</span> <span class="n">rc_str</span>

    <span class="n">alt_sequences</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">left_ref_sequences</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">right_ref_sequences</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">alt_sequences</span><span class="p">,</span> <span class="n">left_ref_sequences</span><span class="p">,</span> <span class="n">right_ref_sequences</span><span class="p">,</span> <span class="n">metadata</span>

    <span class="c1"># Process each breakend pair</span>
    <span class="k">for</span> <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get chromosome sequences</span>
            <span class="n">seq1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">])</span> <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">reference</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">seq2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">])</span> <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">reference</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">seq1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">seq2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Generate fusion sequence using existing ChimericSequenceBuilder</span>
            <span class="n">builder</span> <span class="o">=</span> <span class="n">ChimericSequenceBuilder</span><span class="p">({</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">:</span> <span class="n">seq1</span><span class="p">,</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">:</span> <span class="n">seq2</span><span class="p">})</span>
            <span class="n">fusion_name</span><span class="p">,</span> <span class="n">fusion_seq</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">create_fusion_from_pair</span><span class="p">((</span><span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span><span class="p">))</span>

            <span class="c1"># Detect if this is a BND with insertion and center appropriately</span>
            <span class="n">has_insertion</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">inserted_seq</span> <span class="ow">or</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">has_insertion</span><span class="p">:</span>
                <span class="c1"># For BND with insertion, center window on the inserted sequence</span>
                <span class="c1"># Use segment metadata to find where the novel sequence is located</span>
                <span class="n">segments</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">get_sequence_segments</span><span class="p">(</span><span class="n">fusion_name</span><span class="p">)</span>
                <span class="n">novel_segment</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">source_type</span> <span class="o">==</span> <span class="s2">&quot;novel&quot;</span><span class="p">:</span>
                        <span class="n">novel_segment</span> <span class="o">=</span> <span class="n">seg</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">novel_segment</span><span class="p">:</span>
                    <span class="c1"># Center window on the novel sequence</span>
                    <span class="n">novel_center</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">novel_segment</span><span class="o">.</span><span class="n">start_pos</span> <span class="o">+</span> <span class="n">novel_segment</span><span class="o">.</span><span class="n">end_pos</span>
                    <span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">window_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">novel_center</span> <span class="o">-</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_len</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Fallback to standard centering if no novel segment found</span>
                    <span class="n">center_pos</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>
                    <span class="n">window_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_pos</span> <span class="o">-</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_len</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Standard BND: center on first breakend position</span>
                <span class="n">center_pos</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_pos</span> <span class="o">-</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_len</span>

            <span class="c1"># Generate ALT sequence (fusion sequence window)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fusion_seq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">seq_len</span><span class="p">:</span>
                <span class="n">alt_seq</span> <span class="o">=</span> <span class="n">fusion_seq</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Pad if fusion is shorter than window</span>
                <span class="n">alt_seq</span> <span class="o">=</span> <span class="n">fusion_seq</span> <span class="o">+</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">fusion_seq</span><span class="p">))</span>

            <span class="c1"># Generate reference sequences with appropriate padding</span>
            <span class="c1"># For BNDs with insertions, we need to account for the inserted sequence length</span>
            <span class="n">half_len</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">insertion_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd2</span><span class="o">.</span><span class="n">inserted_seq</span><span class="p">)</span>

            <span class="c1"># Generate left reference sequence (sequence before breakend + right-side N-padding)</span>
            <span class="c1"># For BNDs, we want to show what was there BEFORE the fusion point</span>
            <span class="c1"># Then pad the right side with N&#39;s to represent the missing fusion partner + insertion</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">has_insertion</span><span class="p">:</span>
                <span class="c1"># Standard BND: use existing logic</span>
                <span class="n">center_pos</span> <span class="o">=</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based if not set above</span>
            <span class="n">left_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_pos</span> <span class="o">-</span> <span class="n">half_len</span><span class="p">)</span>
            <span class="n">left_end</span> <span class="o">=</span> <span class="n">center_pos</span>  <span class="c1"># Stop at the breakend position</span>
            <span class="n">left_ref_raw</span> <span class="o">=</span> <span class="n">seq1</span><span class="p">[</span><span class="n">left_start</span><span class="p">:</span><span class="n">left_end</span><span class="p">]</span>

            <span class="c1"># For BND with insertion, pad for both the missing chromosome and the insertion</span>
            <span class="n">left_padding_needed</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_ref_raw</span><span class="p">)</span>
            <span class="c1"># Note: The padding represents what&#39;s missing (other chromosome + insertion)</span>
            <span class="c1"># but we don&#39;t artificially inflate it since the user wants to see proper N-padding</span>
            <span class="n">left_ref_seq</span> <span class="o">=</span> <span class="n">left_ref_raw</span> <span class="o">+</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">left_padding_needed</span>

            <span class="c1"># Generate right reference sequence (left-side N-padding + sequence after breakend)</span>
            <span class="c1"># For the right side, we want to show what was there AFTER the fusion point</span>
            <span class="c1"># Pad the left side with N&#39;s to represent the missing fusion partner + insertion</span>
            <span class="n">bnd2_center</span> <span class="o">=</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>

            <span class="c1"># Extract sequence starting from the breakend (after the fusion point)</span>
            <span class="n">right_start</span> <span class="o">=</span> <span class="n">bnd2_center</span>  <span class="c1"># Start at the breakend position</span>
            <span class="n">right_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq2</span><span class="p">),</span> <span class="n">bnd2_center</span> <span class="o">+</span> <span class="n">half_len</span><span class="p">)</span>
            <span class="n">right_ref_raw</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">right_start</span><span class="p">:</span><span class="n">right_end</span><span class="p">]</span>

            <span class="c1"># For BND with insertion, pad for both the missing chromosome and the insertion</span>
            <span class="n">right_padding_needed</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_ref_raw</span><span class="p">)</span>
            <span class="c1"># Note: The padding represents what&#39;s missing (other chromosome + insertion)</span>
            <span class="c1"># but we don&#39;t artificially inflate it since the user wants to see proper N-padding</span>
            <span class="n">right_ref_seq</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">right_padding_needed</span> <span class="o">+</span> <span class="n">right_ref_raw</span>

            <span class="c1"># Apply reverse complement if needed based on orientation</span>
            <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;t]p]&quot;</span><span class="p">,</span> <span class="s2">&quot;[p[t&quot;</span><span class="p">]:</span>  <span class="c1"># orientations requiring RC</span>
                <span class="n">left_ref_seq</span> <span class="o">=</span> <span class="n">rc_str</span><span class="p">(</span><span class="n">left_ref_seq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;t]p]&quot;</span><span class="p">,</span> <span class="s2">&quot;[p[t&quot;</span><span class="p">]:</span>
                <span class="n">right_ref_seq</span> <span class="o">=</span> <span class="n">rc_str</span><span class="p">(</span><span class="n">right_ref_seq</span><span class="p">)</span>

            <span class="c1"># Ensure sequences are exactly seq_len</span>
            <span class="n">alt_seq</span> <span class="o">=</span> <span class="n">alt_seq</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span>
            <span class="n">left_ref_seq</span> <span class="o">=</span> <span class="n">left_ref_seq</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span>
            <span class="n">right_ref_seq</span> <span class="o">=</span> <span class="n">right_ref_seq</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span>

            <span class="n">alt_sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alt_seq</span><span class="p">)</span>
            <span class="n">left_ref_sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_ref_seq</span><span class="p">)</span>
            <span class="n">right_ref_sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_ref_seq</span><span class="p">)</span>

            <span class="c1"># Create metadata for this BND</span>
            <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;chrom&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                    <span class="s2">&quot;window_start&quot;</span><span class="p">:</span> <span class="n">window_start</span><span class="p">,</span>
                    <span class="s2">&quot;window_end&quot;</span><span class="p">:</span> <span class="n">window_end</span><span class="p">,</span>
                    <span class="s2">&quot;variant_pos0&quot;</span><span class="p">:</span> <span class="n">center_pos</span><span class="p">,</span>
                    <span class="s2">&quot;variant_pos1&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                    <span class="s2">&quot;ref&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                    <span class="s2">&quot;alt&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span>
                    <span class="s2">&quot;variant_type&quot;</span><span class="p">:</span> <span class="s2">&quot;SV_BND&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;mate_chrom&quot;</span><span class="p">:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                    <span class="s2">&quot;mate_pos&quot;</span><span class="p">:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                    <span class="s2">&quot;orientation_1&quot;</span><span class="p">:</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
                    <span class="s2">&quot;orientation_2&quot;</span><span class="p">:</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
                    <span class="s2">&quot;fusion_name&quot;</span><span class="p">:</span> <span class="n">fusion_name</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Log error but continue processing other BNDs</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to process BND pair </span><span class="si">{</span><span class="n">bnd1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">bnd2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

    <span class="c1"># Encode sequences if requested</span>
    <span class="k">if</span> <span class="n">encode</span> <span class="ow">and</span> <span class="n">alt_sequences</span><span class="p">:</span>
        <span class="c1"># Encode each sequence individually and collect them</span>
        <span class="n">encoded_alt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">encoded_left_ref</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">encoded_right_ref</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alt_sequences</span><span class="p">)):</span>
            <span class="n">encoded_alt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encode_seq</span><span class="p">(</span><span class="n">alt_sequences</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">encoder</span><span class="p">))</span>
            <span class="n">encoded_left_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encode_seq</span><span class="p">(</span><span class="n">left_ref_sequences</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">encoder</span><span class="p">))</span>
            <span class="n">encoded_right_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encode_seq</span><span class="p">(</span><span class="n">right_ref_sequences</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">encoder</span><span class="p">))</span>

        <span class="c1"># Stack the encoded sequences</span>
        <span class="k">if</span> <span class="n">TORCH_AVAILABLE</span><span class="p">:</span>
            <span class="n">alt_sequences</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_alt</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_alt</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">left_ref_sequences</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_left_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_left_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>
            <span class="n">right_ref_sequences</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_right_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_right_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alt_sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_alt</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_alt</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">left_ref_sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_left_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_left_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">right_ref_sequences</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">encoded_right_ref</span><span class="p">)</span> <span class="k">if</span> <span class="n">encoded_right_ref</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">alt_sequences</span><span class="p">,</span> <span class="n">left_ref_sequences</span><span class="p">,</span> <span class="n">right_ref_sequences</span><span class="p">,</span> <span class="n">metadata</span>


<div class="viewcode-block" id="get_alt_sequences">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.get_alt_sequences">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_alt_sequences</span><span class="p">(</span>
    <span class="n">reference_fn</span><span class="p">,</span>
    <span class="n">variants_fn</span><span class="p">,</span>
    <span class="n">seq_len</span><span class="p">,</span>
    <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">n_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create sequence windows centered on each variant position with variants applied.</span>
<span class="sd">    Now supports both standard variants and BND variants.</span>

<span class="sd">    Args:</span>
<span class="sd">        reference_fn: Path to reference genome file or dictionary-like object</span>
<span class="sd">        variants_fn: Path to VCF file (string) or DataFrame with variant data.</span>
<span class="sd">                    For DataFrames, position column can be &#39;pos&#39;, &#39;pos1&#39;, or assumes second column is position.</span>
<span class="sd">        seq_len: Length of the sequence window</span>
<span class="sd">        encode: Return sequences as one-hot encoded numpy arrays (default: True)</span>
<span class="sd">        n_chunks: Number of chunks to split variants into (default: 1)</span>
<span class="sd">        encoder: Optional custom encoding function</span>
<span class="sd">        auto_map_chromosomes: Automatically map chromosome names between VCF and reference</span>
<span class="sd">                             when they don&#39;t match exactly. Default: False. (default: False)</span>

<span class="sd">    Yields:</span>
<span class="sd">        Tuple containing (sequences, metadata_df) where:</span>
<span class="sd">            If encode=True: sequences is a tensor/array of shape (chunk_size, seq_len, 4) for each chunk</span>
<span class="sd">            If encode=False: sequences is a list of tuples containing (chrom, start, end, sequence_string) for each chunk</span>
<span class="sd">            metadata_df is a DataFrame with variant information including position offsets</span>
<span class="sd">            For BND variants: sequences contain fusion sequences</span>

<span class="sd">    Raises:</span>
<span class="sd">        ChromosomeMismatchError: If auto_map_chromosomes=False and chromosome names don&#39;t match</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load reference and variants, separating BNDs from standard variants</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_breakend_variants</span>

    <span class="n">reference</span> <span class="o">=</span> <span class="n">_load_reference</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">)</span>

    <span class="c1"># Load variants and separate BNDs</span>
    <span class="n">standard_variants</span><span class="p">,</span> <span class="n">breakend_pairs</span> <span class="o">=</span> <span class="n">load_breakend_variants</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">)</span>

    <span class="c1"># Combine chromosome names from both standard variants and breakend pairs</span>
    <span class="n">ref_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">standard_chroms</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">breakend_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="n">breakend_chroms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
        <span class="n">breakend_chroms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
    <span class="n">vcf_chroms</span> <span class="o">=</span> <span class="n">standard_chroms</span> <span class="o">|</span> <span class="n">breakend_chroms</span>

    <span class="c1"># Use chromosome matching to handle name mismatches</span>
    <span class="n">mapping</span><span class="p">,</span> <span class="n">unmatched</span> <span class="o">=</span> <span class="n">match_chromosomes_with_report</span><span class="p">(</span>
        <span class="n">ref_chroms</span><span class="p">,</span> <span class="n">vcf_chroms</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="n">auto_map_chromosomes</span>
    <span class="p">)</span>

    <span class="c1"># Apply chromosome name mapping to standard variants</span>
    <span class="k">if</span> <span class="n">mapping</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">standard_variants</span> <span class="o">=</span> <span class="n">apply_chromosome_mapping</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>

    <span class="c1"># Apply chromosome name mapping to breakend pairs</span>
    <span class="k">if</span> <span class="n">mapping</span> <span class="ow">and</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="n">updated_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
            <span class="c1"># Update chromosome names in breakend objects if needed</span>
            <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd1</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd2</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">]</span>
            <span class="n">updated_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span><span class="p">))</span>
        <span class="n">breakend_pairs</span> <span class="o">=</span> <span class="n">updated_pairs</span>

    <span class="c1"># Process standard variants and BNDs separately, then combine results</span>
    <span class="c1"># For now, we&#39;ll process all in one chunk (BND chunking is more complex)</span>

    <span class="c1"># Process standard variants first - yield each chunk individually</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Split standard variants into chunks</span>
        <span class="n">std_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)),</span> <span class="n">n_chunks</span><span class="p">)</span>
        <span class="n">std_variant_chunks</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">standard_variants</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">chunk_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">chunk_indices</span> <span class="ow">in</span> <span class="n">std_indices</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">chunk_variants</span> <span class="ow">in</span> <span class="n">std_variant_chunks</span><span class="p">:</span>
            <span class="n">sequences</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Vectorized calculation of window positions for ALL variants in chunk</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">chunk_variants</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>
            <span class="n">half_len</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">window_starts</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">-</span> <span class="n">half_len</span>
            <span class="n">window_ends</span> <span class="o">=</span> <span class="n">window_starts</span> <span class="o">+</span> <span class="n">seq_len</span>

            <span class="c1"># Cache for reference chromosome access</span>
            <span class="n">current_chrom</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ref_seq</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">chrom_length</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Track valid indices for metadata filtering</span>
            <span class="n">valid_indices</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Process each variant individually (applying only that single variant)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunk_variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()):</span>
                <span class="n">chrom</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">]</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span>

                <span class="c1"># Load reference chromosome (with caching)</span>
                <span class="k">if</span> <span class="n">chrom</span> <span class="o">!=</span> <span class="n">current_chrom</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Chromosome </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2"> not found in reference. Skipping variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>
                        <span class="c1"># Skip this variant - don&#39;t add to sequences</span>
                        <span class="k">continue</span>
                    <span class="n">ref_seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">chrom</span><span class="p">])</span>
                    <span class="n">chrom_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">)</span>
                    <span class="n">current_chrom</span> <span class="o">=</span> <span class="n">chrom</span>

                <span class="c1"># Track that this variant was successfully processed</span>
                <span class="n">valid_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="c1"># Use pre-calculated window positions</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="n">window_starts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_ends</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="c1"># Calculate padding and actual bounds</span>
                <span class="k">if</span> <span class="n">window_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">left_pad</span> <span class="o">=</span> <span class="o">-</span><span class="n">window_start</span>
                    <span class="n">actual_start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left_pad</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">actual_start</span> <span class="o">=</span> <span class="n">window_start</span>

                <span class="k">if</span> <span class="n">window_end</span> <span class="o">&gt;</span> <span class="n">chrom_length</span><span class="p">:</span>
                    <span class="n">right_pad</span> <span class="o">=</span> <span class="n">window_end</span> <span class="o">-</span> <span class="n">chrom_length</span>
                    <span class="n">actual_end</span> <span class="o">=</span> <span class="n">chrom_length</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">right_pad</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">actual_end</span> <span class="o">=</span> <span class="n">window_end</span>

                <span class="c1"># Apply ONLY this single variant to reference sequence</span>
                <span class="n">single_var_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">var</span><span class="p">])</span>
                <span class="n">applicator</span> <span class="o">=</span> <span class="n">VariantApplicator</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">,</span> <span class="n">single_var_df</span><span class="p">)</span>
                <span class="n">modified_seq</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">applicator</span><span class="o">.</span><span class="n">apply_variants</span><span class="p">()</span>

                <span class="c1"># Extract window from the single-variant modified sequence</span>
                <span class="n">window_seq</span> <span class="o">=</span> <span class="n">modified_seq</span><span class="p">[</span><span class="n">actual_start</span><span class="p">:</span><span class="n">actual_end</span><span class="p">]</span>

                <span class="c1"># Add padding if needed</span>
                <span class="k">if</span> <span class="n">left_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">window_seq</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">left_pad</span> <span class="o">+</span> <span class="n">window_seq</span>
                <span class="k">if</span> <span class="n">right_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">window_seq</span> <span class="o">=</span> <span class="n">window_seq</span> <span class="o">+</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">right_pad</span>

                <span class="c1"># Truncate or pad as needed</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">seq_len</span><span class="p">:</span>
                    <span class="n">window_seq</span> <span class="o">+=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">window_seq</span> <span class="o">=</span> <span class="n">window_seq</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span>

                <span class="c1"># Ensure correct length</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">seq_len</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Sequence length mismatch for variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="n">seq_len</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">encode</span><span class="p">:</span>
                    <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encode_seq</span><span class="p">(</span><span class="n">window_seq</span><span class="p">,</span> <span class="n">encoder</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">genomic_pos</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">chrom</span><span class="p">,</span>
                            <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">half_len</span><span class="p">),</span>
                            <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">half_len</span><span class="p">)</span> <span class="o">+</span> <span class="n">seq_len</span><span class="p">,</span>
                            <span class="n">window_seq</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># Generate metadata only for successfully processed variants</span>
            <span class="k">if</span> <span class="n">valid_indices</span><span class="p">:</span>
                <span class="n">filtered_chunk</span> <span class="o">=</span> <span class="n">chunk_variants</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
                    <span class="n">drop</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">metadata_df</span> <span class="o">=</span> <span class="n">_generate_sequence_metadata</span><span class="p">(</span><span class="n">filtered_chunk</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No valid variants in this chunk, create empty metadata</span>
                <span class="n">metadata_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

            <span class="c1"># Yield each chunk immediately</span>
            <span class="k">if</span> <span class="n">encode</span> <span class="ow">and</span> <span class="n">sequences</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">TORCH_AVAILABLE</span><span class="p">:</span>
                    <span class="n">sequences_result</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sequences_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sequences_result</span> <span class="o">=</span> <span class="n">sequences</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">sequences_result</span><span class="p">,</span> <span class="n">metadata_df</span><span class="p">)</span>

    <span class="c1"># Process BND variants</span>
    <span class="n">bnd_alt_sequences</span><span class="p">,</span> <span class="n">bnd_left_refs</span><span class="p">,</span> <span class="n">bnd_right_refs</span><span class="p">,</span> <span class="n">bnd_metadata</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_generate_bnd_sequences</span><span class="p">(</span><span class="n">breakend_pairs</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">encode</span><span class="p">,</span> <span class="n">encoder</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Process BND variants after standard variants (if any)</span>
    <span class="c1"># BND variants are yielded as a single batch for now</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_alt_sequences</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bnd_metadata_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bnd_metadata</span><span class="p">)</span> <span class="k">if</span> <span class="n">bnd_metadata</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># BND sequences are already stacked by _generate_bnd_sequences</span>
        <span class="n">bnd_sequences_result</span> <span class="o">=</span> <span class="n">bnd_alt_sequences</span>

        <span class="k">yield</span> <span class="p">(</span><span class="n">bnd_sequences_result</span><span class="p">,</span> <span class="n">bnd_metadata_df</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_ref_sequences">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.get_ref_sequences">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_ref_sequences</span><span class="p">(</span>
    <span class="n">reference_fn</span><span class="p">,</span>
    <span class="n">variants_fn</span><span class="p">,</span>
    <span class="n">seq_len</span><span class="p">,</span>
    <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">n_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create reference sequence windows centered on each variant position (no variants applied).</span>

<span class="sd">    Args:</span>
<span class="sd">        reference_fn: Path to reference genome file or dictionary-like object</span>
<span class="sd">        variants_fn: Path to VCF file (string) or DataFrame with variant data.</span>
<span class="sd">                    For DataFrames, position column can be &#39;pos&#39;, &#39;pos1&#39;, or assumes second column is position.</span>
<span class="sd">        seq_len: Length of the sequence window</span>
<span class="sd">        encode: Return sequences as one-hot encoded numpy arrays (default: True)</span>
<span class="sd">        n_chunks: Number of chunks to split variants into (default: 1)</span>
<span class="sd">        encoder: Optional custom encoding function</span>
<span class="sd">        auto_map_chromosomes: Automatically map chromosome names between VCF and reference</span>
<span class="sd">                             when they don&#39;t match exactly. Default: False. (default: False)</span>

<span class="sd">    Yields:</span>
<span class="sd">        Tuple containing (sequences, metadata_df) where:</span>
<span class="sd">            If encode=True: sequences is a tensor/array of shape (chunk_size, seq_len, 4) for each chunk</span>
<span class="sd">            If encode=False: sequences is a list of tuples containing (chrom, start, end, sequence_string) for each chunk</span>
<span class="sd">            metadata_df is a DataFrame with variant information including position offsets</span>
<span class="sd">            For BND variants: sequences contain dual reference sequences (left + right)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ChromosomeMismatchError: If auto_map_chromosomes=False and chromosome names don&#39;t match</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load reference and variants, separating BNDs from standard variants</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.variant_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_breakend_variants</span>

    <span class="n">reference</span> <span class="o">=</span> <span class="n">_load_reference</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">)</span>

    <span class="c1"># Load variants and separate BNDs</span>
    <span class="n">standard_variants</span><span class="p">,</span> <span class="n">breakend_pairs</span> <span class="o">=</span> <span class="n">load_breakend_variants</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">)</span>

    <span class="c1"># Combine chromosome names from both standard variants and breakend pairs</span>
    <span class="n">ref_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">standard_chroms</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">breakend_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="n">breakend_chroms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
        <span class="n">breakend_chroms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
    <span class="n">vcf_chroms</span> <span class="o">=</span> <span class="n">standard_chroms</span> <span class="o">|</span> <span class="n">breakend_chroms</span>

    <span class="c1"># Use chromosome matching to handle name mismatches</span>
    <span class="n">mapping</span><span class="p">,</span> <span class="n">unmatched</span> <span class="o">=</span> <span class="n">match_chromosomes_with_report</span><span class="p">(</span>
        <span class="n">ref_chroms</span><span class="p">,</span> <span class="n">vcf_chroms</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="n">auto_map_chromosomes</span>
    <span class="p">)</span>

    <span class="c1"># Apply chromosome name mapping to standard variants</span>
    <span class="k">if</span> <span class="n">mapping</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">standard_variants</span> <span class="o">=</span> <span class="n">apply_chromosome_mapping</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>

    <span class="c1"># Apply chromosome name mapping to breakend pairs</span>
    <span class="k">if</span> <span class="n">mapping</span> <span class="ow">and</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="n">updated_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span> <span class="ow">in</span> <span class="n">breakend_pairs</span><span class="p">:</span>
            <span class="c1"># Update chromosome names in breakend objects if needed</span>
            <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">chrom</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">chrom</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bnd1</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd1</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd1</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bnd2</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">bnd2</span><span class="o">.</span><span class="n">mate_chrom</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">bnd2</span><span class="o">.</span><span class="n">mate_chrom</span><span class="p">]</span>
            <span class="n">updated_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">bnd1</span><span class="p">,</span> <span class="n">bnd2</span><span class="p">))</span>
        <span class="n">breakend_pairs</span> <span class="o">=</span> <span class="n">updated_pairs</span>

    <span class="c1"># Process standard variants first - yield each chunk individually</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Split standard variants into chunks</span>
        <span class="n">std_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">standard_variants</span><span class="p">)),</span> <span class="n">n_chunks</span><span class="p">)</span>
        <span class="n">std_variant_chunks</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">standard_variants</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">chunk_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">chunk_indices</span> <span class="ow">in</span> <span class="n">std_indices</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">chunk_variants</span> <span class="ow">in</span> <span class="n">std_variant_chunks</span><span class="p">:</span>
            <span class="n">sequences</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Generate standardized metadata using shared function</span>
            <span class="n">metadata_df</span> <span class="o">=</span> <span class="n">_generate_sequence_metadata</span><span class="p">(</span><span class="n">chunk_variants</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>

            <span class="c1"># Group variants by chromosome for efficient processing</span>
            <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">chrom_variants</span> <span class="ow">in</span> <span class="n">chunk_variants</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;chrom&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Chromosome </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2"> not found in reference. Skipping </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom_variants</span><span class="p">)</span><span class="si">}</span><span class="s2"> variants.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">ref_seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">chrom</span><span class="p">])</span>
                <span class="n">chrom_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">)</span>

                <span class="c1"># Vectorized calculation of window positions</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">chrom_variants</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Convert to 0-based</span>
                <span class="n">half_len</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">window_starts</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">-</span> <span class="n">half_len</span>
                <span class="n">window_ends</span> <span class="o">=</span> <span class="n">window_starts</span> <span class="o">+</span> <span class="n">seq_len</span>

                <span class="c1"># Process all variants in this chromosome using NumPy operations</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chrom_variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()):</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span>
                    <span class="n">genomic_pos</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">window_start</span> <span class="o">=</span> <span class="n">window_starts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_ends</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                    <span class="c1"># Handle edge cases and extract window</span>
                    <span class="k">if</span> <span class="n">window_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">left_pad</span> <span class="o">=</span> <span class="o">-</span><span class="n">window_start</span>
                        <span class="n">actual_start</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">left_pad</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">actual_start</span> <span class="o">=</span> <span class="n">window_start</span>

                    <span class="k">if</span> <span class="n">window_end</span> <span class="o">&gt;</span> <span class="n">chrom_length</span><span class="p">:</span>
                        <span class="n">right_pad</span> <span class="o">=</span> <span class="n">window_end</span> <span class="o">-</span> <span class="n">chrom_length</span>
                        <span class="n">actual_end</span> <span class="o">=</span> <span class="n">chrom_length</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">right_pad</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">actual_end</span> <span class="o">=</span> <span class="n">window_end</span>

                    <span class="c1"># Extract window from reference chromosome (no variants applied)</span>
                    <span class="n">window_seq</span> <span class="o">=</span> <span class="n">ref_seq</span><span class="p">[</span><span class="n">actual_start</span><span class="p">:</span><span class="n">actual_end</span><span class="p">]</span>

                    <span class="c1"># Add padding if needed</span>
                    <span class="k">if</span> <span class="n">left_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">window_seq</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">left_pad</span> <span class="o">+</span> <span class="n">window_seq</span>
                    <span class="k">if</span> <span class="n">right_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">window_seq</span> <span class="o">=</span> <span class="n">window_seq</span> <span class="o">+</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">right_pad</span>

                    <span class="c1"># Ensure correct length</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">seq_len</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Sequence length mismatch for variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="n">seq_len</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="c1"># Truncate or pad as needed</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">seq_len</span><span class="p">:</span>
                            <span class="n">window_seq</span> <span class="o">+=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_seq</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">window_seq</span> <span class="o">=</span> <span class="n">window_seq</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">encode</span><span class="p">:</span>
                        <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encode_seq</span><span class="p">(</span><span class="n">window_seq</span><span class="p">,</span> <span class="n">encoder</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="n">chrom</span><span class="p">,</span>
                                <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">half_len</span><span class="p">),</span>
                                <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">half_len</span><span class="p">)</span> <span class="o">+</span> <span class="n">seq_len</span><span class="p">,</span>
                                <span class="n">window_seq</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

            <span class="c1"># Yield each chunk immediately</span>
            <span class="k">if</span> <span class="n">encode</span> <span class="ow">and</span> <span class="n">sequences</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">TORCH_AVAILABLE</span><span class="p">:</span>
                    <span class="n">sequences_result</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sequences_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sequences_result</span> <span class="o">=</span> <span class="n">sequences</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">sequences_result</span><span class="p">,</span> <span class="n">metadata_df</span><span class="p">)</span>

    <span class="c1"># Process BND variants after standard variants (if any)</span>
    <span class="c1"># BND variants are yielded as dual references</span>
    <span class="k">if</span> <span class="n">breakend_pairs</span><span class="p">:</span>
        <span class="n">bnd_left_refs</span><span class="p">,</span> <span class="n">bnd_right_refs</span><span class="p">,</span> <span class="n">bnd_metadata</span> <span class="o">=</span> <span class="n">_generate_bnd_ref_sequences</span><span class="p">(</span>
            <span class="n">breakend_pairs</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">encode</span><span class="p">,</span> <span class="n">encoder</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_left_refs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bnd_right_refs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bnd_metadata_df</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bnd_metadata</span><span class="p">)</span> <span class="k">if</span> <span class="n">bnd_metadata</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># For ref sequences, we return dual references as a tuple</span>
            <span class="c1"># This is different from get_alt_sequences which returns fusion sequences</span>
            <span class="c1"># BND ref sequences are already stacked by _generate_bnd_ref_sequences</span>
            <span class="n">bnd_left_result</span> <span class="o">=</span> <span class="n">bnd_left_refs</span>
            <span class="n">bnd_right_result</span> <span class="o">=</span> <span class="n">bnd_right_refs</span>

            <span class="c1"># Return dual references as a tuple (left_refs, right_refs)</span>
            <span class="k">yield</span> <span class="p">((</span><span class="n">bnd_left_result</span><span class="p">,</span> <span class="n">bnd_right_result</span><span class="p">),</span> <span class="n">bnd_metadata_df</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_alt_ref_sequences">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.get_alt_ref_sequences">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_alt_ref_sequences</span><span class="p">(</span>
    <span class="n">reference_fn</span><span class="p">,</span>
    <span class="n">variants_fn</span><span class="p">,</span>
    <span class="n">seq_len</span><span class="p">,</span>
    <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">n_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create both reference and variant sequence windows for alt/ref ratio calculations.</span>
<span class="sd">    Maintains backward compatibility while supporting BND variants with dual references.</span>

<span class="sd">    This wrapper function calls both get_ref_sequences and get_alt_sequences to return</span>
<span class="sd">    matching pairs of reference and variant sequences for computing ratios.</span>

<span class="sd">    Args:</span>
<span class="sd">        reference_fn: Path to reference genome file or dictionary-like object</span>
<span class="sd">        variants_fn: Path to VCF file (string) or DataFrame with variant data.</span>
<span class="sd">                    For DataFrames, position column can be &#39;pos&#39;, &#39;pos1&#39;, or assumes second column is position.</span>
<span class="sd">        seq_len: Length of the sequence window</span>
<span class="sd">        encode: Return sequences as one-hot encoded numpy arrays (default: True)</span>
<span class="sd">        n_chunks: Number of chunks to split variants into (default: 1)</span>
<span class="sd">        encoder: Optional custom encoder function</span>
<span class="sd">        auto_map_chromosomes: Automatically map chromosome names between VCF and reference</span>
<span class="sd">                             when they don&#39;t match exactly. Default: False. (default: False)</span>

<span class="sd">    Yields:</span>
<span class="sd">        Tuple containing (alt_sequences, ref_sequences, metadata_df):</span>
<span class="sd">            For standard variants:</span>
<span class="sd">            - alt_sequences: Variant sequences with mutations applied</span>
<span class="sd">            - ref_sequences: Reference sequences without mutations</span>
<span class="sd">            - metadata_df: Variant metadata (pandas DataFrame)</span>

<span class="sd">            For BND variants:</span>
<span class="sd">            - alt_sequences: Fusion sequences from breakend pairs</span>
<span class="sd">            - ref_sequences: Tuple of (left_ref_sequences, right_ref_sequences)</span>
<span class="sd">            - metadata_df: BND metadata with orientation and mate information</span>

<span class="sd">    Metadata DataFrame columns:</span>
<span class="sd">        Standard fields (all variants):</span>
<span class="sd">            - chrom: Chromosome name (str)</span>
<span class="sd">            - window_start: Window start position, 0-based (int)</span>
<span class="sd">            - window_end: Window end position, 0-based exclusive (int)</span>
<span class="sd">            - variant_pos0: Variant position, 0-based (int)</span>
<span class="sd">            - variant_pos1: Variant position, 1-based VCF standard (int)</span>
<span class="sd">            - ref: Reference allele (str)</span>
<span class="sd">            - alt: Alternate allele (str)</span>
<span class="sd">            - variant_type: Variant classification (str)</span>
<span class="sd">                Examples: &#39;SNV&#39;, &#39;INS&#39;, &#39;DEL&#39;, &#39;MNV&#39;, &#39;SV_INV&#39;, &#39;SV_DUP&#39;, &#39;SV_BND&#39;</span>

<span class="sd">        Additional field for symbolic alleles (&lt;INV&gt;, &lt;DUP&gt;, etc.):</span>
<span class="sd">            - sym_variant_end: END position from INFO field, 1-based (int, optional)</span>

<span class="sd">        BND-specific fields:</span>
<span class="sd">            - mate_chrom: Mate breakend chromosome (str)</span>
<span class="sd">            - mate_pos: Mate breakend position, 1-based (int)</span>
<span class="sd">            - orientation_1: First breakend orientation (str)</span>
<span class="sd">            - orientation_2: Second breakend orientation (str)</span>
<span class="sd">            - fusion_name: Fusion sequence identifier (str, optional)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ChromosomeMismatchError: If auto_map_chromosomes=False and chromosome names don&#39;t match</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get generators for both reference and variant sequences</span>
    <span class="c1"># These already handle variant loading, chromosome matching, and chunking consistently</span>
    <span class="n">ref_gen</span> <span class="o">=</span> <span class="n">get_ref_sequences</span><span class="p">(</span>
        <span class="n">reference_fn</span><span class="p">,</span>
        <span class="n">variants_fn</span><span class="p">,</span>
        <span class="n">seq_len</span><span class="p">,</span>
        <span class="n">encode</span><span class="p">,</span>
        <span class="n">n_chunks</span><span class="p">,</span>
        <span class="n">encoder</span><span class="p">,</span>
        <span class="n">auto_map_chromosomes</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">alt_gen</span> <span class="o">=</span> <span class="n">get_alt_sequences</span><span class="p">(</span>
        <span class="n">reference_fn</span><span class="p">,</span>
        <span class="n">variants_fn</span><span class="p">,</span>
        <span class="n">seq_len</span><span class="p">,</span>
        <span class="n">encode</span><span class="p">,</span>
        <span class="n">n_chunks</span><span class="p">,</span>
        <span class="n">encoder</span><span class="p">,</span>
        <span class="n">auto_map_chromosomes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Process chunks from both generators</span>
    <span class="c1"># Both generators will yield chunks in the same order:</span>
    <span class="c1"># 1. Standard variant chunks first (if any) - maintains existing behavior</span>
    <span class="c1"># 2. BND variant chunks last (if any) - new dual reference structure</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ref_chunk</span><span class="p">,</span> <span class="n">ref_metadata</span><span class="p">),</span> <span class="p">(</span><span class="n">alt_chunk</span><span class="p">,</span> <span class="n">alt_metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_gen</span><span class="p">,</span> <span class="n">alt_gen</span><span class="p">):</span>
        <span class="c1"># For standard variants: preserve existing behavior exactly</span>
        <span class="c1"># For BND variants: ref_chunk will be (left_refs, right_refs) tuple</span>
        <span class="c1"># The caller can detect BND chunks by checking if ref_chunk is a tuple</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">alt_chunk</span><span class="p">,</span> <span class="n">ref_chunk</span><span class="p">,</span> <span class="n">ref_metadata</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_pam_disrupting_alt_sequences">
<a class="viewcode-back" href="../../autoapi/supremo_lite/personalize/index.html#supremo_lite.get_pam_disrupting_alt_sequences">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_pam_disrupting_alt_sequences</span><span class="p">(</span>
    <span class="n">reference_fn</span><span class="p">,</span>
    <span class="n">variants_fn</span><span class="p">,</span>
    <span class="n">seq_len</span><span class="p">,</span>
    <span class="n">max_pam_distance</span><span class="p">,</span>
    <span class="n">pam_sequence</span><span class="o">=</span><span class="s2">&quot;NGG&quot;</span><span class="p">,</span>
    <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">n_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate sequences for variants that disrupt PAM sites.</span>

<span class="sd">    This function identifies variants that disrupt existing PAM sites in the reference</span>
<span class="sd">    genome and generates sequence pairs for each disrupting variant. Works like</span>
<span class="sd">    get_alt_ref_sequences() but filtered to only PAM-disrupting variants.</span>

<span class="sd">    Args:</span>
<span class="sd">        reference_fn: Path to reference genome file or dictionary-like object</span>
<span class="sd">        variants_fn: Path to variants file or DataFrame</span>
<span class="sd">        seq_len: Length of sequence windows</span>
<span class="sd">        max_pam_distance: Maximum distance from variant to PAM site</span>
<span class="sd">        pam_sequence: PAM sequence pattern (default: &#39;NGG&#39; for SpCas9).</span>
<span class="sd">                     Supports all IUPAC degenerate nucleotide codes:</span>
<span class="sd">                     N (any), R (A/G), Y (C/T), W (A/T), S (C/G), M (A/C),</span>
<span class="sd">                     K (G/T), B (C/G/T), D (A/G/T), H (A/C/T), V (A/C/G)</span>
<span class="sd">        encode: Return sequences as one-hot encoded numpy arrays (default: True)</span>
<span class="sd">        n_chunks: Number of chunks to split variants for processing (default: 1)</span>
<span class="sd">        encoder: Optional custom encoding function</span>
<span class="sd">        auto_map_chromosomes: Automatically map chromosome names between VCF and reference</span>
<span class="sd">                             when they don&#39;t match exactly. Default: False. (default: False)</span>

<span class="sd">    Yields:</span>
<span class="sd">        Tuple containing (alt_sequences, ref_sequences, metadata_df):</span>
<span class="sd">            - alt_sequences: Variant sequences with mutations applied</span>
<span class="sd">            - ref_sequences: Reference sequences without mutations</span>
<span class="sd">            - metadata_df: Variant metadata (pandas DataFrame) with PAM-specific columns</span>

<span class="sd">    Metadata DataFrame columns:</span>
<span class="sd">        Standard fields:</span>
<span class="sd">            - chrom: Chromosome name (str)</span>
<span class="sd">            - window_start: Window start position, 0-based (int)</span>
<span class="sd">            - window_end: Window end position, 0-based exclusive (int)</span>
<span class="sd">            - variant_pos0: Variant position, 0-based (int)</span>
<span class="sd">            - variant_pos1: Variant position, 1-based VCF standard (int)</span>
<span class="sd">            - ref: Reference allele (str)</span>
<span class="sd">            - alt: Alternate allele (str)</span>
<span class="sd">            - variant_type: Variant classification (str)</span>

<span class="sd">        PAM-specific fields:</span>
<span class="sd">            - pam_site_pos: 0-based start position of PAM site in window (int)</span>
<span class="sd">            - pam_ref_sequence: PAM sequence in reference (str)</span>
<span class="sd">            - pam_alt_sequence: PAM sequence after variant (str)</span>
<span class="sd">            - pam_distance: Distance from variant to PAM start (int)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ChromosomeMismatchError: If auto_map_chromosomes=False and chromosome names don&#39;t match</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # Process all PAM-disrupting variants at once</span>
<span class="sd">        &gt;&gt;&gt; gen = get_pam_disrupting_alt_sequences(ref, vcf, seq_len=50,</span>
<span class="sd">        ...                                         max_pam_distance=10, n_chunks=1)</span>
<span class="sd">        &gt;&gt;&gt; alt_seqs, ref_seqs, metadata = next(gen)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Or iterate through chunks</span>
<span class="sd">        &gt;&gt;&gt; for alt_seqs, ref_seqs, metadata in get_pam_disrupting_alt_sequences(</span>
<span class="sd">        ...     ref, vcf, seq_len=50, max_pam_distance=10, n_chunks=5):</span>
<span class="sd">        ...     predictions = model.predict(alt_seqs, ref_seqs)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Helper function to find PAM sites in a sequence</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_pam_sites</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">pam_pattern</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find all PAM site positions in a sequence using IUPAC codes.</span>

<span class="sd">        Supports IUPAC degenerate nucleotide codes in the pattern (N, R, Y, W, S, M, K, B, D, H, V).</span>
<span class="sd">        Pattern wildcards match corresponding bases in the sequence.</span>
<span class="sd">        Sequence &#39;N&#39; (used for padding or unknown bases) matches any pattern base.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seq_upper</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">pat_upper</span> <span class="o">=</span> <span class="n">pam_pattern</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_upper</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat_upper</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pat_upper</span><span class="p">)):</span>
                <span class="n">seq_base</span> <span class="o">=</span> <span class="n">seq_upper</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">pat_base</span> <span class="o">=</span> <span class="n">pat_upper</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="c1"># Sequence &#39;N&#39; (padding or unknown) matches any pattern base</span>
                <span class="k">if</span> <span class="n">seq_base</span> <span class="o">==</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Always matches</span>

                <span class="c1"># Get allowed bases for this pattern position</span>
                <span class="n">allowed_bases</span> <span class="o">=</span> <span class="n">IUPAC_CODES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pat_base</span><span class="p">,</span> <span class="n">pat_base</span><span class="p">)</span>

                <span class="c1"># Remove brackets from character class if present</span>
                <span class="k">if</span> <span class="n">allowed_bases</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">):</span>
                    <span class="n">allowed_bases</span> <span class="o">=</span> <span class="n">allowed_bases</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Check if sequence base is in the pattern&#39;s allowed bases</span>
                <span class="k">if</span> <span class="n">seq_base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_bases</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sites</span>

    <span class="c1"># Load reference and variants</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">_load_reference</span><span class="p">(</span><span class="n">reference_fn</span><span class="p">)</span>
    <span class="n">variants</span> <span class="o">=</span> <span class="n">_load_variants</span><span class="p">(</span><span class="n">variants_fn</span><span class="p">)</span>

    <span class="c1"># Get all chromosome names and apply chromosome matching</span>
    <span class="n">ref_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">vcf_chroms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variants</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

    <span class="c1"># Use chromosome matching to handle name mismatches</span>
    <span class="n">mapping</span><span class="p">,</span> <span class="n">unmatched</span> <span class="o">=</span> <span class="n">match_chromosomes_with_report</span><span class="p">(</span>
        <span class="n">ref_chroms</span><span class="p">,</span> <span class="n">vcf_chroms</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auto_map_chromosomes</span><span class="o">=</span><span class="n">auto_map_chromosomes</span>
    <span class="p">)</span>

    <span class="c1"># Apply chromosome name mapping to variants</span>
    <span class="k">if</span> <span class="n">mapping</span><span class="p">:</span>
        <span class="n">variants</span> <span class="o">=</span> <span class="n">apply_chromosome_mapping</span><span class="p">(</span><span class="n">variants</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>

    <span class="c1"># Filter variants to find those that disrupt PAM sites</span>
    <span class="n">pam_disrupting_variants_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pam_metadata_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Process each variant to identify PAM disruption</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variants</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">chrom</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;chrom&quot;</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;pos1&quot;</span><span class="p">]</span>  <span class="c1"># 1-based position</span>

        <span class="c1"># Get reference sequence for this chromosome</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Chromosome </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2"> not found in reference. Skipping variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">ref_seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">chrom</span><span class="p">])</span>
        <span class="n">chrom_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">)</span>

        <span class="c1"># Convert to 0-based position</span>
        <span class="n">genomic_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Calculate window boundaries centered on variant start</span>
        <span class="n">half_len</span> <span class="o">=</span> <span class="n">seq_len</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">window_start</span> <span class="o">=</span> <span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">half_len</span>
        <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_len</span>

        <span class="c1"># Check if variant extends past window boundaries</span>
        <span class="n">ref_allele</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt_allele</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alt&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">variant_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_allele</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">))</span>
        <span class="n">variant_end</span> <span class="o">=</span> <span class="n">genomic_pos</span> <span class="o">+</span> <span class="n">variant_length</span>

        <span class="k">if</span> <span class="n">variant_end</span> <span class="o">&gt;</span> <span class="n">window_end</span><span class="p">:</span>
            <span class="n">overflow</span> <span class="o">=</span> <span class="n">variant_end</span> <span class="o">-</span> <span class="n">window_end</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variant at </span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> extends </span><span class="si">{</span><span class="n">overflow</span><span class="si">}</span><span class="s2"> bp beyond the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;requested window (length: </span><span class="si">{</span><span class="n">seq_len</span><span class="si">}</span><span class="s2"> bp). This may affect &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;PAM site detection accuracy.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Handle edge cases for reference sequence PAM detection</span>
        <span class="k">if</span> <span class="n">window_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">left_pad</span> <span class="o">=</span> <span class="o">-</span><span class="n">window_start</span>
            <span class="n">ref_window_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_pad</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_window_start</span> <span class="o">=</span> <span class="n">window_start</span>

        <span class="k">if</span> <span class="n">window_end</span> <span class="o">&gt;</span> <span class="n">chrom_length</span><span class="p">:</span>
            <span class="n">right_pad</span> <span class="o">=</span> <span class="n">window_end</span> <span class="o">-</span> <span class="n">chrom_length</span>
            <span class="n">ref_window_end</span> <span class="o">=</span> <span class="n">chrom_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right_pad</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_window_end</span> <span class="o">=</span> <span class="n">window_end</span>

        <span class="c1"># Extract window from reference for PAM detection</span>
        <span class="n">ref_window_seq</span> <span class="o">=</span> <span class="n">ref_seq</span><span class="p">[</span><span class="n">ref_window_start</span><span class="p">:</span><span class="n">ref_window_end</span><span class="p">]</span>

        <span class="c1"># Add padding for PAM detection</span>
        <span class="k">if</span> <span class="n">left_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ref_window_seq</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">left_pad</span> <span class="o">+</span> <span class="n">ref_window_seq</span>
        <span class="k">if</span> <span class="n">right_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ref_window_seq</span> <span class="o">=</span> <span class="n">ref_window_seq</span> <span class="o">+</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">right_pad</span>

        <span class="c1"># Find PAM sites in the reference sequence window</span>
        <span class="n">ref_pam_sites</span> <span class="o">=</span> <span class="n">_find_pam_sites</span><span class="p">(</span><span class="n">ref_window_seq</span><span class="p">,</span> <span class="n">pam_sequence</span><span class="p">)</span>

        <span class="c1"># Calculate variant position in padded window</span>
        <span class="n">variant_pos_in_window</span> <span class="o">=</span> <span class="n">left_pad</span> <span class="o">+</span> <span class="p">(</span><span class="n">genomic_pos</span> <span class="o">-</span> <span class="n">ref_window_start</span><span class="p">)</span>

        <span class="c1"># Filter PAM sites that are within max_pam_distance of the variant</span>
        <span class="n">nearby_ref_pam_sites</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">p</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ref_pam_sites</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">variant_pos_in_window</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_pam_distance</span>
        <span class="p">]</span>

        <span class="c1"># Skip if no nearby PAM sites</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nearby_ref_pam_sites</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Create a temporary applicator with just this variant</span>
        <span class="n">single_var_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">var</span><span class="p">])</span>
        <span class="n">temp_applicator</span> <span class="o">=</span> <span class="n">VariantApplicator</span><span class="p">(</span><span class="n">ref_seq</span><span class="p">,</span> <span class="n">single_var_df</span><span class="p">)</span>

        <span class="c1"># Apply the variant to get the full modified chromosome</span>
        <span class="n">modified_chrom</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">temp_applicator</span><span class="o">.</span><span class="n">apply_variants</span><span class="p">()</span>

        <span class="c1"># Extract window from modified chromosome</span>
        <span class="k">if</span> <span class="n">window_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">actual_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">actual_start</span> <span class="o">=</span> <span class="n">window_start</span>

        <span class="k">if</span> <span class="n">window_end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">modified_chrom</span><span class="p">):</span>
            <span class="n">actual_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modified_chrom</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">actual_end</span> <span class="o">=</span> <span class="n">window_end</span>

        <span class="n">modified_window</span> <span class="o">=</span> <span class="n">modified_chrom</span><span class="p">[</span><span class="n">actual_start</span><span class="p">:</span><span class="n">actual_end</span><span class="p">]</span>

        <span class="c1"># Add padding</span>
        <span class="k">if</span> <span class="n">left_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">modified_window</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">left_pad</span> <span class="o">+</span> <span class="n">modified_window</span>
        <span class="k">if</span> <span class="n">right_pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">modified_window</span> <span class="o">=</span> <span class="n">modified_window</span> <span class="o">+</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="n">right_pad</span>

        <span class="c1"># Ensure correct length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">modified_window</span><span class="p">)</span> <span class="o">!=</span> <span class="n">seq_len</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">modified_window</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">seq_len</span><span class="p">:</span>
                <span class="n">modified_window</span> <span class="o">+=</span> <span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">seq_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">modified_window</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">modified_window</span> <span class="o">=</span> <span class="n">modified_window</span><span class="p">[:</span><span class="n">seq_len</span><span class="p">]</span>

        <span class="c1"># Check for new PAM formation in the alternate sequence</span>
        <span class="c1"># Find PAM sites in the modified (alternate) sequence</span>
        <span class="n">alt_pam_sites</span> <span class="o">=</span> <span class="n">_find_pam_sites</span><span class="p">(</span><span class="n">modified_window</span><span class="p">,</span> <span class="n">pam_sequence</span><span class="p">)</span>

        <span class="c1"># Filter to nearby PAM sites in the alternate sequence</span>
        <span class="n">nearby_alt_pam_sites</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">p</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">alt_pam_sites</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">variant_pos_in_window</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_pam_distance</span>
        <span class="p">]</span>

        <span class="c1"># Identify which reference PAM sites are truly disrupted</span>
        <span class="c1"># Different logic for SNVs vs INDELs:</span>
        <span class="c1"># - SNV: PAM disrupted if the exact PAM sequence changes at that position</span>
        <span class="c1"># - INDEL: PAM disrupted ONLY if no PAM exists in ALT (even at shifted position)</span>
        <span class="c1">#         If INDEL creates/shifts a PAM, it&#39;s NOT considered disrupting</span>

        <span class="n">ref_allele</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt_allele</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alt&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">is_indel</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">ref_allele</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_allele</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ref_allele</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span> <span class="ow">or</span> <span class="n">alt_allele</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span>
        <span class="p">)</span>

        <span class="n">truly_disrupted_pam_sites</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">is_indel</span><span class="p">:</span>
            <span class="c1"># For INDELs: check if PAM still exists anywhere nearby (allowing for shifts)</span>
            <span class="k">for</span> <span class="n">ref_pam_pos</span> <span class="ow">in</span> <span class="n">nearby_ref_pam_sites</span><span class="p">:</span>
                <span class="n">pam_still_exists</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">alt_pam_pos</span> <span class="ow">in</span> <span class="n">nearby_alt_pam_sites</span><span class="p">:</span>
                    <span class="c1"># Allow for positional shifts due to the INDEL</span>
                    <span class="c1"># If a PAM exists within a reasonable distance, consider it maintained</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ref_pam_pos</span> <span class="o">-</span> <span class="n">alt_pam_pos</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pam_sequence</span><span class="p">):</span>
                        <span class="n">pam_still_exists</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">pam_still_exists</span><span class="p">:</span>
                    <span class="n">truly_disrupted_pam_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_pam_pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For SNVs: check if the PAM sequence at the exact position has changed</span>
            <span class="k">for</span> <span class="n">ref_pam_pos</span> <span class="ow">in</span> <span class="n">nearby_ref_pam_sites</span><span class="p">:</span>
                <span class="c1"># Extract the PAM sequence from both ref and alt at this exact position</span>
                <span class="n">ref_pam_seq</span> <span class="o">=</span> <span class="n">ref_window_seq</span><span class="p">[</span>
                    <span class="n">ref_pam_pos</span> <span class="p">:</span> <span class="n">ref_pam_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pam_sequence</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">alt_pam_seq</span> <span class="o">=</span> <span class="n">modified_window</span><span class="p">[</span>
                    <span class="n">ref_pam_pos</span> <span class="p">:</span> <span class="n">ref_pam_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pam_sequence</span><span class="p">)</span>
                <span class="p">]</span>

                <span class="c1"># Check if the PAM pattern still matches after the variant</span>
                <span class="n">alt_matches_pattern</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="s2">&quot;N&quot;</span>
                    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">alt_pam_seq</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">pam_sequence</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                <span class="p">)</span>

                <span class="c1"># If the ALT no longer matches the PAM pattern, it&#39;s disrupted</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">alt_matches_pattern</span><span class="p">:</span>
                    <span class="n">truly_disrupted_pam_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_pam_pos</span><span class="p">)</span>

        <span class="c1"># Only proceed if there are truly disrupted PAM sites</span>
        <span class="c1"># If all reference PAMs are maintained (possibly at shifted positions for INDELs),</span>
        <span class="c1"># skip this variant</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">truly_disrupted_pam_sites</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># For each disrupted PAM site, create a metadata entry</span>
        <span class="k">for</span> <span class="n">pam_site_pos</span> <span class="ow">in</span> <span class="n">truly_disrupted_pam_sites</span><span class="p">:</span>
            <span class="c1"># Extract PAM sequences</span>
            <span class="n">ref_pam_seq</span> <span class="o">=</span> <span class="n">ref_window_seq</span><span class="p">[</span>
                <span class="n">pam_site_pos</span> <span class="p">:</span> <span class="n">pam_site_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pam_sequence</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">alt_pam_seq</span> <span class="o">=</span> <span class="n">modified_window</span><span class="p">[</span>
                <span class="n">pam_site_pos</span> <span class="p">:</span> <span class="n">pam_site_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pam_sequence</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># Calculate distance from variant to PAM</span>
            <span class="n">pam_distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pam_site_pos</span> <span class="o">-</span> <span class="n">variant_pos_in_window</span><span class="p">)</span>

            <span class="c1"># Store the variant (may be duplicate if multiple PAMs disrupted)</span>
            <span class="n">pam_disrupting_variants_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

            <span class="c1"># Store PAM-specific metadata</span>
            <span class="n">pam_metadata_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;pam_site_pos&quot;</span><span class="p">:</span> <span class="n">pam_site_pos</span><span class="p">,</span>
                    <span class="s2">&quot;pam_ref_sequence&quot;</span><span class="p">:</span> <span class="n">ref_pam_seq</span><span class="p">,</span>
                    <span class="s2">&quot;pam_alt_sequence&quot;</span><span class="p">:</span> <span class="n">alt_pam_seq</span><span class="p">,</span>
                    <span class="s2">&quot;pam_distance&quot;</span><span class="p">:</span> <span class="n">pam_distance</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

    <span class="c1"># If no PAM-disrupting variants found, yield empty results</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pam_disrupting_variants_list</span><span class="p">:</span>
        <span class="c1"># Return empty generator</span>
        <span class="k">return</span>

    <span class="c1"># Create DataFrame with filtered PAM-disrupting variants</span>
    <span class="n">filtered_variants_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pam_disrupting_variants_list</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
        <span class="n">drop</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">pam_metadata_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pam_metadata_list</span><span class="p">)</span>

    <span class="c1"># Call get_alt_ref_sequences with the filtered variants</span>
    <span class="k">for</span> <span class="n">alt_seqs</span><span class="p">,</span> <span class="n">ref_seqs</span><span class="p">,</span> <span class="n">base_metadata</span> <span class="ow">in</span> <span class="n">get_alt_ref_sequences</span><span class="p">(</span>
        <span class="n">reference_fn</span><span class="p">,</span>
        <span class="n">filtered_variants_df</span><span class="p">,</span>
        <span class="n">seq_len</span><span class="p">,</span>
        <span class="n">encode</span><span class="p">,</span>
        <span class="n">n_chunks</span><span class="p">,</span>
        <span class="n">encoder</span><span class="p">,</span>
        <span class="n">auto_map_chromosomes</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Merge PAM-specific metadata with base metadata</span>
        <span class="c1"># Both should have the same number of rows since we created one entry per PAM site</span>
        <span class="n">enriched_metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">base_metadata</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">pam_metadata_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="c1"># Yield the chunk with enriched metadata</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">alt_seqs</span><span class="p">,</span> <span class="n">ref_seqs</span><span class="p">,</span> <span class="n">enriched_metadata</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Gladstone Institutes.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>